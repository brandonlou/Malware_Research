import argparse
import json
import os

class ResourceHelper:
    file_handles = {}

    @classmethod
    def get_file_handle(self, filepath):
        return self.file_handles.get(filepath)

    @classmethod
    def add_file(self, file_handle, filepath):
        self.file_handles[filepath] = file_handle


# Temporary resource sequences
temp_file_seqs = {} # File handles --> API sequences
temp_reg_seqs = {}  # Reg handles --> API sequences


# Commited resource sequences
committed_file_seqs = []


def append_to_seq(handle_to_seq, handle, api):
    if handle_to_seq.get(handle) is None:
        handle_to_seq[handle] = [api]
    else:
        handle_to_seq[handle].append(api)


def process_api(call, current_pid):
    api = call.get('api')

    if api == 'NtQueryAttributesFile':
        filepath = call.get('arguments').get('filepath')
        file_handle = ResourceHelper().get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtReadFile':
        file_handle = call.get('arguments').get('file_handle')
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtWriteFile':
        file_handle = call.get('arguments').get('file_handle')
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtCreateFile':
        file_handle = call.get('arguments').get('filehandle')
        filepath = call.get('arguments').get('filename')
        ResourceHelper.add_file(file_handle, filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'DeleteFileW' or api == 'DeleteFileA':
        filepath = call.get('arguments').get('filepath')
        file_handle = ResourceHelper.get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)
        committed_file_seqs.append(temp_file_seqs[file_handle])
        del temp_file_seqs[file_handle]

    elif api == 'NtOpenFile':
        file_handle = call.get('arguments').get('file_handle')
        filepath = call.get('arguments').get('filepath')
        ResourceHelper.add_file(file_handle, filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'FindFirstFileExW':
        filepath = call.get('arguments').get('filepath')
        file_handle = ResourceHelper().get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtQueryInformationFile':
        file_handle = call.get('arguments').get('file_handle')
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtQuerySystemInformation':
        pass # No resource

    elif api == 'CopyFileA':
        filepath1 = call.get('arguments').get('oldfilepath')
        filepath2 = call.get('arguments').get('newfilepath')
        file_handle1 = ResourceHelper().get_file_handle(filepath1)
        file_handle2 = ResourceHelper().get_file_handle(filepath2)
        append_to_seq(temp_file_seqs, file_handle1, api)
        append_to_seq(temp_file_seqs, file_handle2, api)

    elif api == 'MoveFileWithProgressW':
        filepath1 = call.get('arguments').get('oldfilepath')
        filepath2 = call.get('arguments').get('newfilepath')
        file_handle1 = ResourceHelper().get_file_handle(filepath1)
        file_handle2 = ResourceHelper().get_file_handle(filepath2)
        append_to_seq(temp_file_seqs, file_handle1, api)
        append_to_seq(temp_file_seqs, file_handle2, api)

    elif api == 'NtQueryDirectoryFile':
        filepath = call.get('arguments').get('dirpath')
        file_handle = ResourceHelper().get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtOpenDirectoryObject':
        filepath = call.get('arguments').get('dirpath')
        file_handle = ResourceHelper().get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'NtSetInformationFile':
        file_handle = call.get('arguments').get('file_handle')
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'SetFileAttributesW' or api == 'SetFileAttributesA':
        filepath = call.get('arguments').get('filepath')
        file_handle = ResourceHelper().get_file_handle(filepath)
        append_to_seq(temp_file_seqs, file_handle, api)

    elif api == 'RegSetValueExA' or api == 'RegSetValueExW':
        key_handle = call.get('arguments').get('key_handle')
        regkey = call.get('arguments').get('regkey')

    elif api == 'RegOpenKeyExW' or api == 'RegOpenKeyExA' or api == 'NtOpenKey' or api == 'NtOpenKeyEx':
        key_handle = call.get('arguments').get('key_handle')
        regkey = call.get('arguments').get('regkey')

    elif api == 'RegCreateKeyExA' or api == 'RegCreateKeyExW':
        key_handle = call.get('arguments').get('key_handle')
        regkey = call.get('arguments').get('regkey')

    elif api == 'NtQueryValueKey' or api == 'RegQueryValueExW' or api == 'RegQueryValueExA':
        key_handle = call.get('arguments').get('key_handle')
        regkey = call.get('arguments').get('regkey')

    elif api == 'CreateProcessInternalW':
        comamnd_line = call.get('arguments').get('command_line') # Usually a file

    elif api == 'RtlCreateUserProcess':
        tid = call.get('arguments').get('thread_identifier')
        pid = call.get('arguments').get('process_identifier')
        filepath = call.get('arguments').get('filepath')
        process_handle = call.get('arguments').get('parent_process_handle')

    elif api == 'ShellExecuteExW':
        filepath = call.get('arguments').get('filepath')

    elif api == 'ReadProcessMemory':
        process_handle = call.get('arguments').get('process_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'WriteProcessMemory':
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')

    elif api == 'Process32FirstW':
        pid = call.get('arguments').get('process_identifier')
        snapshot_handle = call.get('arguments').get('snapshot_handle')
        process_name = call.get('arguments').get('process_name')

    elif api == 'Process32NextW':
        pid = call.get('arguments').get('process_identifier')
        snapshot_handle = call.get('arguments').get('snapshot_handle')
        process_name = call.get('arguments').get('process_name')

    elif api == 'FindWindowA' or api == 'FindWindowW':
        window_handle = '0x{:08x}'.format(call.get('return_value'))
        window = call.get('arguments').get('class_name') + ':' + call.get('arguments').get('window_name')

    elif api == 'GetForegroundWindow':
        if call.get('return_value') != 0:
            handle = '0x{:08x}'.format(call.get('return_value'))
            window = 'FOREGROUND'

    elif api == 'GetCursorPos':
        resource = 'CURSOR'

    elif api == 'GetKeyState':
        resource = 'KEYBOARD\\' + str(call.get('arguments').get('key_code'))

    elif api == 'GetComputerNameA':
        # No resource
        pass

    elif api == 'GetUserNameW':
        # No resource
        pass

    elif api == 'GetSystemInfo':
        # No resource
        pass

    elif api == 'GetSystemTimeAsFileTime':
        # No resource
        pass

    elif api == 'GetTempPathW':
        dirpath = call.get('arguments').get('dirpath')

    elif api == 'GetSystemDirectoryW':
        dirpath = call.get('arguments').get('dirpath')

    elif api == 'GetSystemMetrics':
        # No resource
        pass

    elif api == 'gethostbyname':
        hostname = call.get('arguments').get('hostname')

    elif api == 'connect':
        ip_address = call.get('arguments').get('ip_address')

    elif api == 'getaddrinfo':
        hostname = call.get('arguments').get('hostname')

    elif api == 'NtCreateMutant':
        mutant_name = call.get('arguments').get('mutant_name')
        mutant_handle = call.get('arguments').get('handle')

    elif api == 'NtOpenMutant':
        mutant_name = call.get('arguments').get('mutant_name')
        mutant_handle = call.get('arguments').get('handle')

    elif api == 'SendNotifyMessageA':
        window_handle = call.get('arguments').get('window_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtQueueApcThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtSetContextThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtResumeThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtOpenProcess':
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')
        tid = call.get('arguments').get('tid')

    elif api == 'MessageBoxTimeoutW':
        # No resource
        pass

    elif api == 'CreateThread' or api == 'NtCreateThreadEx':
        tid = call.get('arguments').get('thread_identifier')

    elif api == 'CreateRemoteThread' or api == 'CreateRemoteThreadEx':
        tid = call.get('arguments').get('thread_identifier')
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')

    elif api == 'NtOpenThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')
        if pid == 0:
            pid = current_pid

    elif api == 'CreateServiceA' or api == 'CreateServiceW':
        filepath = call.get('arguments').get('filepath').split(' ')[0]
        service_handle = call.get('arguments').get('service_handle')

    elif api == 'EnumServicesStatusA':
        service_handle = call.get('arguments').get('service_handle')

    elif api == 'InternetConnectA' or api == 'InternetConnectW':
        hostname = call.get('arguments').get('hostname')
        internet_handle = call.get('arguments').get('internet_handle')

    elif api == 'HttpOpenRequestA' or api =='HttpOpenRequestW':
        connect_handle = call.get('arguments').get('connect_handle')

    elif api == 'HttpSendRequestA' or api == 'HttpSendRequestW':
        request_handle = call.get('arguments').get('request_handle')

    elif api == 'SetWindowsHookExA' or api == 'SetWindowsHookExW':
        hook_id = call.get('arguments').get('hook_identifier')

    elif api == '__exception__':
        module = call.get('arguments').get('exception').get('module')
        if module is None:
            module = 'NOMOD'

    elif api == 'WriteConsoleW' or api == 'WriteConsoleA':
        console_handle = call.get('arguments').get('console_handle')

    elif api == 'DrawTextExA' or api == 'DrawTextExW':
        # No resource
        pass

    elif api == 'OutputDebugStringA':
        # No resource
        pass

    else:
        pass


def main():
    parser = argparse.ArgumentParser(description='Convert Cuckoo JSON reports to API behavior graphs')
    parser.add_argument('input_dir')
    parser.add_argument('output_dir')
    parser.add_argument('verdict')
    args = parser.parse_args()

    input_dir = args.input_dir
    output_dir = args.output_dir
    verdict = args.verdict
    if verdict == '0':
        verdict = 0
    elif verdict == '1':
        verdict = 1
    else:
        print('Error: Verdict must be 0 or 1')
        return

    for filename in os.listdir(input_dir):
        # Open cuckoo report file
        with open(f'{input_dir}/{filename}', 'rt') as cuckoo_report:
            try:
                data = json.load(cuckoo_report)
            except:
                print(f'Error: Could not parse {input_dir}/{filename} as JSON')
                continue

        behavior = data.get('behavior')
        if behavior is None:
            print(f'Error: {input_dir}/{filename} has no behavior section')
            continue

        processes = behavior.get('processes')
        if processes is None:
            print(f'Error: {input_dir}/{filename} has no processes section')
            continue

        # Reset sequences
        temp_file_seqs = {}
        temp_reg_seqs = {}
        committed_file_seqs = []

        for process in processes:
            current_pid = process.get('pid')
            for call in process.get('calls'):
                process_api(call, current_pid)

        for seqs in temp_file_seqs.values():
            committed_file_seqs.append(seqs)

        print(committed_file_seqs)

        print(f'Success: {input_dir}/{filename}')

if __name__ == "__main__":
    main()
