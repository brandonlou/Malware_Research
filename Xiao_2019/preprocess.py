import argparse
import json
import os

class ResourceHelper:
    filepaths = {} # file handle --> file path
    regkeys = {} # reg handle --> regkey

    @classmethod
    def get_filepath(self, file_handle):
        return self.filepaths.get(file_handle)

    @classmethod
    def get_regkey(self, reg_handle):
        return self.regkeys.get(reg_handle)

    @classmethod
    def add_file(self, file_handle, filepath):
        self.filepaths[file_handle] = filepath

    @classmethod
    def add_reg(self, key_handle, regkey):
        self.regkeys[key_handle] = regkey


# Temporary resource sequences
temp_file_seqs = {} # Filepaths --> API sequences
temp_reg_seqs = {}  # Regkeys --> API sequences
exception_seq = []
dummy_seq = []

# Commited resource sequences
all_sequences = []


def append_to_seq(resource_seq, resource, api):
    if resource_seq.get(resource) is None:
        resource_seq[resource] = [api]
    else:
        resource_seq[resource].append(api)


def process_api(call, current_pid):
    api = call.get('api')

    if api == 'NtQueryAttributesFile':
        filepath = call.get('arguments').get('filepath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtReadFile':
        file_handle = call.get('arguments').get('file_handle')
        filepath = ResourceHelper.get_filepath(file_handle)
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtWriteFile':
        filepath = call.get('arguments').get('filepath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtCreateFile':
        file_handle = call.get('arguments').get('filehandle')
        filepath = call.get('arguments').get('filepath')
        ResourceHelper.add_file(file_handle, filepath)
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'DeleteFileW' or api == 'DeleteFileA':
        filepath = call.get('arguments').get('filepath')
        append_to_seq(temp_file_seqs, filepath, api)
        all_sequences.append(temp_file_seqs.get(filepath))
        del temp_file_seqs[filepath]

    elif api == 'NtOpenFile':
        file_handle = call.get('arguments').get('file_handle')
        filepath = call.get('arguments').get('filepath')
        ResourceHelper.add_file(file_handle, filepath)
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'FindFirstFileExW':
        filepath = call.get('arguments').get('filepath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtQueryInformationFile':
        file_handle = call.get('arguments').get('file_handle')
        filepath = ResourceHelper.get_filepath(file_handle)
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtQuerySystemInformation':
        dummy_seq.append(api) # No resource

    elif api == 'CopyFileA':
        filepath1 = call.get('arguments').get('oldfilepath')
        filepath2 = call.get('arguments').get('newfilepath')
        append_to_seq(temp_file_seqs, filepath1, api)
        append_to_seq(temp_file_seqs, filepath2, api)

    elif api == 'MoveFileWithProgressW':
        filepath1 = call.get('arguments').get('oldfilepath')
        filepath2 = call.get('arguments').get('newfilepath')
        append_to_seq(temp_file_seqs, filepath1, api)
        append_to_seq(temp_file_seqs, filepath2, api)

    elif api == 'NtQueryDirectoryFile':
        filepath = call.get('arguments').get('dirpath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtOpenDirectoryObject':
        filepath = call.get('arguments').get('dirpath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'NtSetInformationFile':
        file_handle = call.get('arguments').get('file_handle')
        filepath = ResourceHelper.get_filepath(file_handle)
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'SetFileAttributesW' or api == 'SetFileAttributesA':
        filepath = call.get('arguments').get('filepath')
        append_to_seq(temp_file_seqs, filepath, api)

    elif api == 'RegSetValueExA' or api == 'RegSetValueExW':
        regkey = call.get('arguments').get('regkey')
        append_to_seq(temp_reg_seqs, regkey, api)

    elif api == 'RegOpenKeyExW' or api == 'RegOpenKeyExA' or api == 'NtOpenKey' or api == 'NtOpenKeyEx':
        regkey = call.get('arguments').get('regkey')
        key_handle = call.get('arguments').get('key_handle')
        ResourceHelper.add_reg(key_handle, regkey)
        append_to_seq(temp_reg_seqs, regkey, api)

    elif api == 'RegCreateKeyExA' or api == 'RegCreateKeyExW':
        regkey = call.get('arguments').get('regkey')
        key_handle = call.get('arguments').get('key_handle')
        ResourceHelper.add_reg(key_handle, regkey)
        append_to_seq(temp_reg_seqs, regkey, api)

    elif api == 'NtQueryValueKey' or api == 'RegQueryValueExW' or api == 'RegQueryValueExA':
        regkey = call.get('arguments').get('regkey')
        append_to_seq(temp_reg_seqs, regkey, api)

    elif api == 'CreateProcessInternalW':
        filepath = call.get('arguments').get('command_line')
        append_to_seq(temp_file_seqs, filepath, api)

    # Here

    elif api == 'RtlCreateUserProcess':
        tid = call.get('arguments').get('thread_identifier')
        pid = call.get('arguments').get('process_identifier')
        filepath = call.get('arguments').get('filepath')
        process_handle = call.get('arguments').get('parent_process_handle')

    elif api == 'ShellExecuteExW':
        filepath = call.get('arguments').get('filepath')

    elif api == 'ReadProcessMemory':
        process_handle = call.get('arguments').get('process_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'WriteProcessMemory':
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')

    elif api == 'Process32FirstW':
        pid = call.get('arguments').get('process_identifier')
        process_name = call.get('arguments').get('process_name')

    elif api == 'Process32NextW':
        pid = call.get('arguments').get('process_identifier')
        process_name = call.get('arguments').get('process_name')

    elif api == 'FindWindowA' or api == 'FindWindowW':
        window_handle = '0x{:08x}'.format(call.get('return_value'))
        window = call.get('arguments').get('class_name') + ':' + call.get('arguments').get('window_name')

    elif api == 'GetForegroundWindow':
        if call.get('return_value') != 0:
            handle = '0x{:08x}'.format(call.get('return_value'))
            window = 'FOREGROUND'

    elif api == 'GetCursorPos':
        resource = 'CURSOR'

    elif api == 'GetKeyState':
        resource = 'KEYBOARD\\' + str(call.get('arguments').get('key_code'))

    elif api == 'GetComputerNameA':
        dummy_seq.append(api) # No resource

    elif api == 'GetUserNameW':
        dummy_seq.append(api) # No resource

    elif api == 'GetSystemInfo':
        dummy_seq.append(api) # No resource

    elif api == 'GetSystemTimeAsFileTime':
        dummy_seq.append(api) # No resource

    elif api == 'GetTempPathW':
        dirpath = call.get('arguments').get('dirpath')

    elif api == 'GetSystemDirectoryW':
        dirpath = call.get('arguments').get('dirpath')

    elif api == 'GetSystemMetrics':
        dummy_seq.append(api) # No resource

    elif api == 'gethostbyname':
        hostname = call.get('arguments').get('hostname')

    elif api == 'connect':
        ip_address = call.get('arguments').get('ip_address')

    elif api == 'getaddrinfo':
        hostname = call.get('arguments').get('hostname')

    elif api == 'NtCreateMutant':
        mutant_name = call.get('arguments').get('mutant_name')
        mutant_handle = call.get('arguments').get('handle')

    elif api == 'NtOpenMutant':
        mutant_name = call.get('arguments').get('mutant_name')
        mutant_handle = call.get('arguments').get('handle')

    elif api == 'SendNotifyMessageA':
        window_handle = call.get('arguments').get('window_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtQueueApcThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtSetContextThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtResumeThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')

    elif api == 'NtOpenProcess':
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')
        tid = call.get('arguments').get('tid')

    elif api == 'MessageBoxTimeoutW':
        dummy_seq.append(api) # No resource

    elif api == 'CreateThread' or api == 'NtCreateThreadEx':
        tid = call.get('arguments').get('thread_identifier')

    elif api == 'CreateRemoteThread' or api == 'CreateRemoteThreadEx':
        tid = call.get('arguments').get('thread_identifier')
        pid = call.get('arguments').get('process_identifier')
        process_handle = call.get('arguments').get('process_handle')

    elif api == 'NtOpenThread':
        thread_handle = call.get('arguments').get('thread_handle')
        pid = call.get('arguments').get('process_identifier')
        if pid == 0:
            pid = current_pid

    elif api == 'CreateServiceA' or api == 'CreateServiceW':
        filepath = call.get('arguments').get('filepath').split(' ')[0]
        service_handle = call.get('arguments').get('service_handle')

    elif api == 'EnumServicesStatusA':
        service_handle = call.get('arguments').get('service_handle')

    elif api == 'InternetConnectA' or api == 'InternetConnectW':
        hostname = call.get('arguments').get('hostname')
        internet_handle = call.get('arguments').get('internet_handle')

    elif api == 'HttpOpenRequestA' or api =='HttpOpenRequestW':
        connect_handle = call.get('arguments').get('connect_handle')

    elif api == 'HttpSendRequestA' or api == 'HttpSendRequestW':
        request_handle = call.get('arguments').get('request_handle')

    # elif api == 'SetWindowsHookExA' or api == 'SetWindowsHookExW':
    #     hook_id = call.get('arguments').get('hook_identifier')

    elif api == '__exception__':
        exception_seq.append(api)

    elif api == 'WriteConsoleW' or api == 'WriteConsoleA':
        console_handle = call.get('arguments').get('console_handle')

    elif api == 'DrawTextExA' or api == 'DrawTextExW':
        dummy_seq.append(api) # No resource

    elif api == 'OutputDebugStringA':
        dummy_seq.append(api) # No resource

    else:
        pass


def main():
    parser = argparse.ArgumentParser(description='Convert Cuckoo JSON reports to API behavior graphs')
    parser.add_argument('input_dir')
    parser.add_argument('output_dir')
    parser.add_argument('verdict')
    args = parser.parse_args()

    input_dir = args.input_dir
    output_dir = args.output_dir
    verdict = args.verdict
    if verdict == '0':
        verdict = 0
    elif verdict == '1':
        verdict = 1
    else:
        print('Error: Verdict must be 0 or 1')
        return

    for filename in os.listdir(input_dir):
        # Open cuckoo report file
        with open(f'{input_dir}/{filename}', 'rt') as cuckoo_report:
            try:
                data = json.load(cuckoo_report)
            except:
                print(f'Error: Could not parse {input_dir}/{filename} as JSON')
                continue

        behavior = data.get('behavior')
        if behavior is None:
            print(f'Error: {input_dir}/{filename} has no behavior section')
            continue

        processes = behavior.get('processes')
        if processes is None:
            print(f'Error: {input_dir}/{filename} has no processes section')
            continue

        all_sequences.clear()

        for process in processes:

            # Reset temporary sequences
            temp_file_seqs.clear()
            temp_reg_seqs.clear()
            exception_seq.clear()
            dummy_seq.clear()

            current_pid = process.get('pid')

            for call in process.get('calls'):
                process_api(call, current_pid)

            # Save sequences for resources that didn't close
            for seq in temp_file_seqs.values():
                all_sequences.append(seq)

            for seq in temp_reg_seqs.values():
                all_sequences.append(seq)


        print(all_sequences)

        print(f'Success: {input_dir}/{filename}')

if __name__ == "__main__":
    main()
