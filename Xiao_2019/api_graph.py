import json


# Append an API to a resource sequence based on a resource identifier.
def seq_append(all_seqs, identifier, api_name):
    this_seq = all_seqs.get(identifier)
    if this_seq is None:
        this_seq = [api_name]
    else:
        last_api = this_seq[-1]
        if last_api != api_name: # Prevent duplicate adjacent API calls
            this_seq.append(api_name)
    all_seqs[identifier] = this_seq


def analyze_api(call, current_pid, file_handle_to_path, reg_handle_to_key, 
                window_handle_to_name, process_handle_to_pid,
                service_handle_to_filepath, connect_handle_to_hostname,
                request_handle_to_hostname, file_seqs, reg_seqs, proc_seqs,
                window_seqs, mutant_seqs, service_seqs, internet_seqs,
                exception_seqs, console_seqs, hook_seqs, dummy_seq):
    
    api = call.get('api')

    if api == 'NtQueryAttributesFile':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, api)

    elif api == 'NtReadFile':
        file_handle = int(call['arguments']['file_handle'], 0)
        filepath = file_handle_to_path.get(file_handle)
        if filepath is not None:
            seq_append(file_seqs, filepath, api)

    elif api == 'NtWriteFile':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, api)

    elif api == 'NtCreateFile':
        file_handle = int(call['arguments']['file_handle'], 0)
        filepath = call['arguments']['filepath']
        file_handle_to_path[file_handle] = filepath
        seq_append(file_seqs, filepath, api)

    elif api == 'DeleteFileW' or api == 'DeleteFileA':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, 'DeleteFileA')

    elif api == 'NtOpenFile':
        file_handle = int(call['arguments']['file_handle'], 0)
        filepath = call['arguments']['filepath']
        file_handle_to_path[file_handle] = filepath
        seq_append(file_seqs, filepath, api)

    elif api == 'FindFirstFileExW':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, api)

    elif api == 'NtQueryInformationFile':
        file_handle = int(call['arguments']['file_handle'], 0)
        filepath = file_handle_to_path.get(file_handle)
        if filepath is not None:
            seq_append(file_seqs, filepath, api)

    elif api == 'NtQuerySystemInformation':
        dummy_seq.append(api) # No resource sequence

    elif api == 'CopyFileA':
        filepath1 = call['arguments']['oldfilepath']
        filepath2 = call['arguments']['newfilepath']
        seq_append(file_seqs, filepath1, api)
        seq_append(file_seqs, filepath2, api)

    elif api == 'MoveFileWithProgressW':
        filepath1 = call['arguments']['oldfilepath']
        filepath2 = call['arguments']['newfilepath']
        seq_append(file_seqs, filepath1, api)
        seq_append(file_seqs, filepath2, api)

    elif api == 'NtQueryDirectoryFile':
        filepath = call['arguments']['dirpath']
        seq_append(file_seqs, filepath, api)

    elif api == 'NtOpenDirectoryObject':
        filepath = call['arguments']['dirpath']
        seq_append(file_seqs, filepath, api)

    elif api == 'NtSetInformationFile':
        file_handle = int(call['arguments']['file_handle'], 0)
        filepath = file_handle_to_path.get(file_handle)
        if filepath is not None:
            seq_append(file_seqs, filepath, api)

    elif api == 'SetFileAttributesW' or api == 'SetFileAttributesA':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, 'SetFileAttributesA')

    elif api == 'RegSetValueExA' or api == 'RegSetValueExW':
        regkey = call['arguments']['regkey']
        seq_append(reg_seqs, regkey, 'RegSetValueExA')

    elif api == 'RegOpenKeyExW' or api == 'RegOpenKeyExA' or api == 'NtOpenKey' or api == 'NtOpenKeyEx':
        regkey = call['arguments']['regkey']
        key_handle = int(call['arguments']['key_handle'], 0)
        reg_handle_to_key[key_handle] = regkey
        seq_append(reg_seqs, regkey, 'NtOpenKey')

    elif api == 'RegCreateKeyExA' or api == 'RegCreateKeyExW':
        regkey = call['arguments']['regkey']
        key_handle = int(call['arguments']['key_handle'], 0)
        reg_handle_to_key[key_handle] = regkey
        seq_append(reg_seqs, regkey, 'RegCreateKeyExA')

    elif api == 'NtQueryValueKey' or api == 'RegQueryValueExW' or api == 'RegQueryValueExA':
        regkey = call['arguments']['regkey']
        seq_append(reg_seqs, regkey, 'NtQueryValueKey')

    elif api == 'CreateProcessInternalW':
        filepath = call['arguments']['command_line']
        seq_append(file_seqs, filepath, api)

    elif api == 'RtlCreateUserProcess':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, api)

    elif api == 'ShellExecuteExW':
        filepath = call['arguments']['filepath']
        seq_append(file_seqs, filepath, api)

    elif api == 'ReadProcessMemory':
        process_handle = int(call['arguments']['process_handle'], 0)
        pid = process_handle_to_pid.get(process_handle)
        if pid is not None:
            seq_append(proc_seqs, pid, api)

    elif api == 'WriteProcessMemory':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'Process32FirstW':
        pid = call['arguments']['process_identifier']
        process_handle = int(call['arguments']['snapshot_handle'], 0)
        process_handle_to_pid[process_handle] = pid
        seq_append(proc_seqs, pid, api)

    elif api == 'Process32NextW':
        pid = call['arguments']['process_identifier']
        process_handle = int(call['arguments']['snapshot_handle'], 0)
        process_handle_to_pid[process_handle] = pid
        seq_append(proc_seqs, pid, api)

    elif api == 'FindWindowA' or api == 'FindWindowW':
        window_handle = int(call['return_value'])
        window_name = call['arguments']['class_name'] + ':' + call['arguments']['window_name']
        window_handle_to_name[window_handle] = window_name
        seq_append(window_seqs, window_name, 'FindWindowA')

    elif api == 'GetForegroundWindow':
        if call['return_value'] != 0:
            window_handle = int(call['return_value'])
            window_name = 'FOREGROUND'
            window_handle_to_name[window_handle] = window_name
            seq_append(window_seqs, window_name, api)

    elif api == 'GetCursorPos':
        resource = 'CURSOR'
        dummy_seq.append(api) # No resource sequence

    elif api == 'GetKeyState':
        resource = 'KEYBOARD\\' + str(call['arguments']['key_code'])
        dummy_seq.append(api) # No resource sequence

    elif api == 'GetComputerNameA':
        dummy_seq.append(api) # No resource sequence

    elif api == 'GetUserNameW':
        dummy_seq.append(api) # No resource sequence

    elif api == 'GetSystemInfo':
        dummy_seq.append(api) # No resource sequence

    elif api == 'GetTempPathW':
        filepath = call['arguments']['dirpath']
        seq_append(file_seqs, filepath, api)

    elif api == 'GetSystemDirectoryW':
        filepath = call['arguments']['dirpath']
        seq_append(file_seqs, filepath, api)

    elif api == 'GetSystemMetrics':
        dummy_seq.append(api) # No resource sequence

    elif api == 'gethostbyname':
        hostname = call['arguments']['hostname']
        seq_append(internet_seqs, hostname, api)

    elif api == 'connect':
        hostname = call['arguments']['ip_address']
        seq_append(internet_seqs, hostname, api)

    elif api == 'getaddrinfo':
        hostname = call['arguments']['hostname']
        seq_append(internet_seqs, hostname, api)

    elif api == 'NtCreateMutant':
        mutant_name = call['arguments']['mutant_name']
        seq_append(mutant_seqs, mutant_name, api)

    elif api == 'NtOpenMutant':
        mutant_name = call['arguments']['mutant_name']
        seq_append(mutant_seqs, mutant_name, api)

    elif api == 'SendNotifyMessageA':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

        window_handle = call['arguments']['window_handle']
        window_name = window_handle_to_name.get(window_handle)
        if window_name is not None:
            seq_append(window_seqs, window_name, api)

    elif api == 'NtQueueApcThread':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'NtSetContextThread':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'NtResumeThread':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'NtOpenProcess':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'MessageBoxTimeoutW':
        dummy_seq.append(api) # No resource sequence

    elif api == 'CreateThread':
        seq_append(proc_seqs, current_pid, api)

    elif api == 'NtCreateThreadEx':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'CreateRemoteThread':
        pid = call['arguments']['process_identifier']
        seq_append(proc_seqs, pid, api)

    elif api == 'CreateRemoteThreadEx':
        process_handle = int(call['arguments']['process_handle'], 0)
        if process_handle == 4294967295: #0xffff
            pid = current_pid
        elif process_handle in process_handle_to_pid:
            pid = process_handle_to_pid[process_handle]
        else:
            pid = 0
        seq_append(proc_seqs, pid, api)

    elif api == 'NtOpenThread':
        pid = call['arguments']['process_identifier']
        if pid == 0:
            pid = current_pid
        seq_append(proc_seqs, pid, api)

    elif api == 'CreateServiceA' or api == 'CreateServiceW':
        filepath = call['arguments']['filepath']
        params = filepath.split(' ')
        filepath = params[0]
        seq_append(file_seqs, filepath, 'CreateServiceA')

        service_handle = call['arguments']['service_handle']
        service_handle_to_filepath[service_handle] = filepath
        seq_append(service_seqs, service_handle, api)

    elif api == 'EnumServicesStatusA':
        service_handle = call['arguments']['service_handle']
        seq_append(service_seqs, service_handle, api)

        if service_handle in service_handle_to_filepath:
            filepath = service_handle_to_filepath[service_handle]
            seq_append(file_seqs, filepath, api)

    elif api == 'InternetConnectA' or api == 'InternetConnectW':
        hostname = call['arguments']['hostname']
        seq_append(internet_seqs, hostname, 'InternetConnectA')

        connect_handle = '0x{:08x}'.format(call['return_value'])
        connect_handle_to_hostname[connect_handle] = hostname

        connect_handle = '0x{:016x}'.format(call['return_value'])
        connect_handle_to_hostname[connect_handle] = hostname

    elif api == 'HttpOpenRequestA' or api == 'HttpOpenRequestW':
        connect_handle = call['arguments']['connect_handle']

        if connect_handle in connect_handle_to_hostname:
            hostname = connect_handle_to_hostname[connect_handle]
            seq_append(internet_seqs, hostname, 'HttpOpenRequestA')

            request_handle = '0x{:08x}'.format(call['return_value'])
            request_handle_to_hostname[request_handle] = hostname

            request_handle = '0x{:016x}'.format(call['return_value'])
            request_handle_to_hostname[request_handle] = hostname

    elif api == 'HttpSendRequestA' or api == 'HttpSendRequestW':
        request_handle = call['arguments']['request_handle']
        if request_handle in request_handle_to_hostname:
            hostname = request_handle_to_hostname[request_handle]
            seq_append(internet_seqs, hostname, 'HttpSendRequestA')

    elif api == 'SetWindowsHookExA' or api == 'SetWindowsHookExW':
        hook_identifier = call['flags']['hook_identifier']
        seq_append(hook_seqs, hook_identifier, 'SetWindowsHookExA')

    elif api == '__exception__':
        module = 'NOMOD'
        if 'module' in call['arguments']['exception']:
             module = call['arguments']['exception']['module']
        seq_append(exception_seqs, module, api)

    elif api == 'WriteConsoleW' or api == 'WriteConsoleA':
        console_handle = call['arguments']['console_handle']
        seq_append(console_seqs, console_handle, 'WriteConsoleA')

    elif api == 'DrawTextExA' or api == 'DrawTextExW':
        dummy_seq.append('DrawTextExA') # No resource sequence

    elif api == 'OutputDebugStringA':
        dummy_seq.append(api) # No resource sequence

    else:
        pass


# Returns the API graph of a Cuckoo report
def api_graph(filename):
    with open(filename, 'rt') as cuckoo_report:
        try:
            data = json.load(cuckoo_report)
        except:
            print(f'Error: Could not parse {filename} as JSON')
            return

    behavior = data.get('behavior')
    if behavior is None:
        print(f'Error: {filename} has no behavior section')
        return

    processes = behavior.get('processes')
    if processes is None:
        print(f'Error: {filename} has no processes section')
        return

    file_handle_to_path = {} # File handle --> Filepath
    reg_handle_to_key = {} # Reg handle --> Regkey
    window_handle_to_name = {}
    process_handle_to_pid = {}
    service_handle_to_filepath = {}
    connect_handle_to_hostname = {}
    request_handle_to_hostname = {}
    file_seqs = {}      # Filepath       --> API sequence
    reg_seqs  = {}      # Regkey         --> API sequence
    proc_seqs = {}      # PID            --> API sequence
    window_seqs = {}    # Window name    --> API sequence
    mutant_seqs = {}    # Mutant name    --> API sequence
    service_seqs = {}   # Service handle --> API sequence
    internet_seqs = {}  # Hostname       --> API sequence
    exception_seqs = {} # Module         --> API sequence
    console_seqs = {}   # Console handle --> API sequence
    hook_seqs = {}      # Hook ID        --> API sequence
    dummy_seq = []

    # For each process, analyze its API calls and build an API graph
    for proc in processes:
        current_pid = proc['pid']
        for call in proc.get('calls'):
            analyze_api(call, current_pid, file_handle_to_path, reg_handle_to_key, window_handle_to_name, process_handle_to_pid, service_handle_to_filepath, connect_handle_to_hostname, request_handle_to_hostname, file_seqs, reg_seqs, proc_seqs, window_seqs, mutant_seqs, service_seqs, internet_seqs, exception_seqs, console_seqs, hook_seqs, dummy_seq)

    # Return all API sequences from all resources
    seq_list = list(file_seqs.values()) + list(reg_seqs.values()) + list(proc_seqs.values()) + list(window_seqs.values()) + list(mutant_seqs.values()) + list(service_seqs.values()) + list(internet_seqs.values()) + list(exception_seqs.values())
    all_seqs = set()
    for seq in seq_list:
        all_seqs.add(tuple(seq))
    return all_seqs

