import os
os.environ['OMP_NUM_THREADS'] = '23'
os.environ['TF_NUM_INTRAOP_THREADS'] = '23'
os.environ['TF_NUM_INTEROP_THREADS'] = '23'
import gc
import numpy as np
import pickle
import sys
import tensorflow as tf
from sklearn.metrics import accuracy_score, confusion_matrix, f1_score, precision_score, recall_score, roc_auc_score
from sklearn.model_selection import StratifiedKFold
from sklearn.tree import DecisionTreeClassifier
from statistics import mean
from tensorflow.keras import backend as k
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.callbacks import Callback

NUM_CORES = 23
tf.config.threading.set_intra_op_parallelism_threads(NUM_CORES)
tf.config.threading.set_inter_op_parallelism_threads(NUM_CORES)

NUM_FOLDS = 10
BATCH_SIZE = 1000
EPOCHS = 100
LOSS = 'binary_crossentropy'
OPTIMIZER = 'adam'
TEST_SIZE = 0.2


def chunks(l, n):
    for i in range(n):
        yield l[i::n]


class ClearMemory(Callback):
    def on_epoch_end(self, epoch, logs=None):
        gc.collect()
        k.clear_session()


def main():
    if len(sys.argv) < 2:
        print(f'Usage: python3 {sys.argv[0]} <data pickle>')
        exit()

    # Load data
    X_data = []
    y_data = []
    with open(sys.argv[1], 'rb') as pickled_data:
        data = pickle.load(pickled_data)
        for row in data:
            X_data.append(row[1:])
            y_data.append(row[0])
    input_dim = len(X_data[0])
    X_data = np.array(X_data)
    y_data = np.array(y_data)

    accuracies = []
    precisions = []
    recalls = []
    roc_auc_scores = []
    false_positives = []
    f1_scores = []

    # 10-fold cross validation
    skf = StratifiedKFold(n_splits=NUM_FOLDS, shuffle=True, random_state=None)
    current_fold = 1
    for train_index, test_index in skf.split(X_data, y_data):
        print(f'Fold: {current_fold}')
        current_fold += 1
        X_train, X_test = X_data[train_index], X_data[test_index]
        y_train, y_test = y_data[train_index], y_data[test_index]

        # Stacked autoencoder model
        input_layer  = Input(shape=(input_dim,))
        encode_input = Dense(input_dim, activation='relu')(input_layer)
        encode_6000  = Dense(6000, activation='relu')(encode_input)
        encode_2000  = Dense(2000, activation='relu')(encode_6000)
        encode_500   = Dense(500,  activation='relu')(encode_2000)
        decode_2000  = Dense(2000, activation='relu')(encode_500)
        decode_6000  = Dense(6000, activation='relu')(decode_2000)
        decode_input = Dense(input_dim, activation='relu')(decode_6000)
        model = Model(inputs=input_layer, outputs=decode_input)
        model.compile(loss=LOSS, optimizer=OPTIMIZER)
        model.fit(X_train, X_train, batch_size=BATCH_SIZE, epochs=EPOCHS, callbacks=ClearMemory())    

        # Reduce to 500 features
        new_model = Model(inputs=input_layer, outputs=encode_500)
        new_model.compile(loss=LOSS, optimizer=OPTIMIZER)
        # new_model.save('sae.h5') # Save model to use later for prediction
        X_train = new_model.predict(X_train)
        X_test = new_model.predict(X_test)

        # Train a decision tree
        dtc = DecisionTreeClassifier()
        dtc = dtc.fit(X_train, y_train)
        #with open('dtc.pkl', 'wb') as dtc_pkl:
        #    pickle.dump(dtc, dtc_pkl) # Save model to use later for prediction

        # Predict
        y_pred = dtc.predict(X_test)

        # Calculate metrics
        accuracies.append(accuracy_score(y_test, y_pred))
        precisions.append(precision_score(y_test, y_pred))
        recalls.append(recall_score(y_test, y_pred))
        roc_auc_scores.append(roc_auc_score(y_test, y_pred))
        false_positives.append(confusion_matrix(y_test, y_pred).ravel()[1])
        f1_scores.append(f1_score(y_test, y_pred))

    print(f'{NUM_FOLDS}-fold cross validation')
    print(f'Accuracy: {mean(accuracies)}')
    print(f'Precision: {mean(precisions)}')
    print(f'Recall: {mean(recalls)}')
    print(f'ROC AUC: {mean(roc_auc_scores)}')
    print(f'False Positives: {mean(false_positives)}')
    print(f'F1 Score: {mean(f1_scores)}')


if __name__ == "__main__":
    main()

