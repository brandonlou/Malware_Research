import pickle
import sys
from sklearn.model_selection import KFold
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Input, concatenate
import tensorflow.keras.backend as K
import tensorflow as tf
from sklearn import tree

LAYER_1 = 6000
LAYER_2 = 2000
LAYER_3 = 500
NUM_FOLDS = 10
BATCH_SIZE = 1000
EPOCHS = 100
LOSS = 'binary_crossentropy'
OPTIMIZER = 'adam'


def main():
    if len(sys.argv) < 2:
        print(f'Usage: python3 {sys.argv[0]} <data pickle>')
        exit()

    X_data = []
    y_data = []
    with open(sys.argv[1], 'rb') as pickled_data:
        data = pickle.load(pickled_data)
        for row in data:
            X_data.append(row[1:])
            y_data.append(row[0])

    kfold = KFold(n_splits=NUM_FOLDS, shuffle=True)

    # accuracy = []
    # precision = []
    # recall = []
    # auc = []
    # num_fp = []
    # f1 = []

    #for train, test in kfold.split(X_data, y_data):
    input_dim = len(X_data[0])

    inputs = Input(shape=(input_dim,))
    encode = Dense(input_dim, activation='relu')(inputs)
    hidden = Dense(6000, activation='relu', name='hidden')(encode)
    decode = Dense(input_dim, activation='relu')(hidden)
    ae1 = Model(inputs=inputs, outputs=decode)
    ae1.compile(loss=LOSS, optimizer=OPTIMIZER)
    ae1.fit(X_data, X_data, batch_size=BATCH_SIZE, epochs=EPOCHS)
    intermediate_model = Model(inputs=ae1.input, outputs=ae1.get_layer('hidden').output)
    ae1_output = intermediate_model(X_data)

    inputs = Input(shape=(6000,))
    encode = Dense(6000, activation='relu')(inputs)
    hidden = Dense(2000, activation='relu')(encode)
    decode = Dense(6000, activation='relu')(hidden)
    ae2 = Model(inputs=inputs, outputs=decode)
    ae2.compile(loss=LOSS, optimizer=OPTIMIZER)
    ae2.fit(ae1_output, ae1_output, batch_size=BATCH_SIZE, epochs=EPOCHS)

    inputs = Input(shape=(2000,))
    encode = Dense(2000, activation='relu')(inputs)
    hidden = Dense(500, activation='relu')(encode)
    decode = Dense(2000, activation='relu')(hidden)
    ae3 = Model(inputs=inputs, outputs=decode)
    ae3.compile(loss=LOSS, optimizer=OPTIMIZER)
    ae3.fit(ae2_output, ae2_output, batch_size=BATCH_SIZE, epochs=EPOCHS)


    dtc = tree.DecisionTreeClassifier()
    dtc.fit(ae3_output, y_data)

    # # Report model performance.
    # print(f'Using {NUM_FOLDS}-fold Cross Validation')
    # print(f'Accuracy: {mean(accuracy):.3f}')
    # print(f'Precision: {mean(precision):.3f}')
    # print(f'Recall: {mean(recall):.3f}')
    # print(f'AUC: {mean(auc):.3f}')
    # print(f'Number false positives: {mean(num_fp):.3f}')
    # print(f'F1 Score: {mean(f1):.3f}')


if __name__ == "__main__":
    main()
