import csv
import json
import os
import random

OUTPUT_FILE = '/Volumes/Data/Malware_Samples/data.csv' #'/home/brandon/data.csv'
MAX_SAMPLES = 100
MAX_SEQUENCE_LEN = 10
MIN_SEQUENCES = 5
MAX_SEQUENCES = 75
MASK_VALUE = -10
NUM_OS_RESOURCES = 6
NUM_ATTRIBUTES = 7

OS_Resource = {
    'Any': 0,
    'File': 1,
    'RegistryKey': 2,
    'Thread': 3,
    'Socket': 4,
    'Internet': 5,
    'HTTP': 6
}


Resource_Attribute = {
    'Null': 0,
    'UserFile': 1,
    'SystemFile': 2,
    'HKEY_CLASSES_ROOT': 3,
    'HKEY_CURRENT_USER': 4,
    'HKEY_LOCAL_MACHINE': 5,
    'HKEY_USERS': 6,
    'HKEY_CURRENT_CONFIG': 7
}


class API:
    def __init__(self, handle: int, resource: int, action: int, attribute: int):
        self.handle = handle
        self.resource = resource
        self.action = action
        self.attribute = attribute


class API_Sequence:
    def __init__(self, sequence: list, count: int, resource: int, attribute: int):
        self.sequence = sequence
        self.count = count
        self.resource = resource
        self.attribute = attribute

'''
ACTIONS:
    1. Open Resource
    2. Create Resource
    3. Read
    4. Write
    5. Close
    6. Delete Resource
    7. Suspend
    8. Resume
    9. Set Info/Socket options
    10. Get Info/Socket name
    11. Get Size
    12. Set End
    13. Set Pointer
    14. Get Type
    15. Set Time
    16. Delete Value
    17. Enumerate Values
    18. Set Value
    19. Enumerate Keys
    20. Get Value
    21. Connect Socket
    22. Control Socket I/O
    23. Accept Connection
    24. Listen for Connection
    25. Socket Bind
    26. Socket Receive
    27. Socket Send
    28. Open URL
'''

FILE_APIS = ('NtWriteFile', 'SetFileInformationByHandle', 'GetFileSize', 'GetFileSizeEx',
    'SetEndOfFile', 'SetFilePointerEx', 'GetFileInformationByHandle', 'GetFileInformationByHandleEx',
    'GetFileType', 'NtSetInformationFile', 'NtCreateFile', 'NtQueryInformationFile',
    'NtDeviceIoControlFile', 'NtReadFile', 'SetFilePointer', 'SetFileTime', 'NtOpenFile',
    'NtQueryDirectoryFile')

REG_APIS = ('RegDeleteValueA', 'RegDeleteValueW', 'NtDeleteValueKey', 'RegOpenKeyExW', 'NtOpenKeyEx',
    'NtOpenKey', 'RegOpenKeyExA', 'RegEnumValueA', 'RegEnumValueW', 'NtEnumerateValueKey',
    'RegQueryInfoKeyW', 'RegQueryInfoKeyA', 'NtQueryKey', 'RegSetValueExA', 'RegSetValueExW',
    'NtSetValueKey', 'RegEnumKeyExW', 'RegEnumKeyExA', 'RegEnumKeyW', 'NtEnumerateKey',
    'RegQueryValueExW', 'RegQueryValueExA', 'NtQueryValueKey', 'NtQueryMultipleValueKey',
    'RegDeleteKeyA', 'RegDeleteKeyW', 'NtDeleteKey', 'RegCreateKeyExA', 'RegCreateKeyExW',
    'NtCreateKey', 'RegCloseKey')

SOCK_APIS = ('socket', 'WSASocketW', 'WSASocketA', 'connect', 'iosctlsocket', 'setsockopt',
    'getsockname', 'accept', 'listen', 'bind', 'recv', 'send', 'shutdown', 'closesocket')

INTERNET_APIS = ('InternetOpenW', 'InternetOpenA', 'InternetSetOptionA', 'InternetSetOptionW',
    'InternetQueryOptionA', 'InternetQueryOptionW', 'InternetConnectA', 'InternetConenctW',
    'InternetOpenUrlA', 'InternetOpenUrlW', 'InternetSetStatusCallback', 'InternetCloseHandle')

THREAD_APIS = ('CreateThread', 'NtCreateThreadEx', 'RtlCreateUserThread', 'NtOpenThread',
    'NtSuspendThread', 'NtResumeThread', 'NtGetContextThread', 'NtSetContextThread',
    'NtQueueApcThread')

API_ACTIONS = {
    **dict.fromkeys(['NtOpenFile', 'RegOpenKeyExW', 'NtOpenKeyEx', 'NtOpenKey', 'RegOpenKeyExA',
                     'InternetOpenW', 'InternetOpenA', 'NtOpenThread'], 1),
    **dict.fromkeys(['NtCreateFile', 'RegCreateKeyExA', 'RegCreateKeyExW', 'NtCreateKey', 'socket',
                     'WSASocketW', 'WSASocketA', 'CreateThread', 'NtCreateThreadEx',
                     'RtlCreateUserThread'], 2),
    **dict.fromkeys(['NtReadFile'], 3),
    **dict.fromkeys(['NtWriteFile', 'NtDeviceIoControlFile'], 4),
    **dict.fromkeys(['NtClose', 'RegCloseKey', 'closesocket', 'InternetCloseHandle'], 5),
    **dict.fromkeys(['RegDeleteKeyA', 'RegDeleteKeyW', 'NtDeleteKey', 'shutdown'], 6),
    **dict.fromkeys(['NtSuspendThread'], 7),
    **dict.fromkeys(['NtResumeThread'], 8),
    **dict.fromkeys(['NtSetInformationFile', 'SetFileInformationByHandle', 'setsockopt',
                     'InternetSetOptionA', 'InternetSetOptionW', 'InternetSetStatusCallback',
                     'NtSetContextThread'], 9),
    **dict.fromkeys(['NtQueryInformationFile', 'NtQueryDirectoryFile', 'GetFileInformationByHandle',
                     'GetFileInformationByHandleEx', 'RegQueryInfoKeyW', 'RegQueryInfoKeyA',
                     'NtQueryKey', 'getsockname', 'InternetQueryOptionA', 'InternetQueryOptionW',
                     'NtGetContextThread'], 10),
    **dict.fromkeys(['GetFileSize', 'GetFileSizeEx'], 11),
    **dict.fromkeys(['SetEndOfFile'], 12),
    **dict.fromkeys(['SetFilePointer', 'SetFilePointerEx'], 13),
    **dict.fromkeys(['GetFileType'], 14),
    **dict.fromkeys(['SetFileTime'], 15),
    **dict.fromkeys(['RegDeleteValueA', 'RegDeleteValueW', 'NtDeleteValueKey'], 16),
    **dict.fromkeys(['RegEnumValueA', 'RegEnumValueW', 'NtEnumerateValueKey'], 17),
    **dict.fromkeys(['RegSetValueExA', 'RegSetValueExW', 'NtSetValueKey'], 18),
    **dict.fromkeys(['RegEnumKeyExW', 'RegEnumKeyExA', 'RegEnumKeyW', 'NtEnumerateKey'], 19),
    **dict.fromkeys(['RegQueryValueExW', 'RegQueryValueExA', 'NtQueryValueKey',
                     'NtQueryMultipleValueKey'], 20),
    **dict.fromkeys(['connect', 'InternetConnectA', 'InternetConenctW'], 21),
    **dict.fromkeys(['iosctlsocket'], 22),
    **dict.fromkeys(['accept'], 23),
    **dict.fromkeys(['listen'], 24),
    **dict.fromkeys(['bind'], 25),
    **dict.fromkeys(['recv'], 26),
    **dict.fromkeys(['send'], 27),
    **dict.fromkeys(['NtQueueApcThread'], 28),
    **dict.fromkeys(['InternetOpenUrlA', 'InternetOpenUrlW'], 29)
}


def get_action_num(api_name: str) -> int:
    return API_ACTIONS.get(api_name, -1)


def is_file_api(api_name: str) -> bool:
    return api_name in FILE_APIS


def is_reg_api(api_name: str) -> bool:
    return api_name in REG_APIS


def is_socket_api(api_name: str) -> bool:
    return api_name in SOCK_APIS


def is_internet_api(api_name: str) -> bool:
    return api_name in INTERNET_APIS


def is_thread_api(api_name: str) -> bool:
    return api_name in THREAD_APIS


# Special because NtClose can be used on multiple handles (file, reg keys, etc.)
def is_nt_close(api_name: str) -> bool:
    return api_name == 'NtClose'


def handle_file_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    file_handle = arguments.get('file_handle', None)
    if file_handle is None:
        return None

    if action_num == 1 or action_num == 2:
        filename = arguments.get('filepath', None)
        if 'System32' in filename or 'SysWOW64' in filename:
            attribute = Resource_Attribute['SystemFile']
        else:
            attribute = Resource_Attribute['UserFile']
        return API(file_handle, OS_Resource['File'], action_num, attribute)
    else:
        return API(file_handle, OS_Resource['File'], action_num, Resource_Attribute['Null'])


def handle_reg_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    if api_name == 'NtQueryMultipleValueKey':
        key_handle = arguments.get('KeyHandle')
    else:
        key_handle = arguments.get('key_handle', None)
    if key_handle is None:
        return None

    attribute = Resource_Attribute['Null']
    if action_num == 1 or action_num == 2:
        key_name = arguments.get('regkey', None)
        if 'HKEY_CLASSES_ROOT' in key_name:
            attribute = Resource_Attribute['HKEY_CLASSES_ROOT']
        elif 'HKEY_CURRENT_USER' in key_name:
            attribute = Resource_Attribute['HKEY_CURRENT_USER']
        elif 'HKEY_LOCAL_MACHINE' in key_name:
            attribute = Resource_Attribute['HKEY_LOCAL_MACHINE']
        elif 'HKEY_USERS' in key_name:
            attribute = Resource_Attribute['HKEY_USERS']
        elif 'HKEY_CURRENT_CONFIG' in key_name:
            attribute = Resource_Attribute['HKEY_CURRENT_CONFIG']

    return API(key_handle, OS_Resource['RegistryKey'], action_num, attribute)


def handle_socket_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None

    if api_name in ('socket', 'WSASocketW', 'WSASocketA'):
        sock_fd = call.get('return_value')
    elif api_name == 'getsockname':
        sock_fd = arguments.get('s')
    else:
        sock_fd = arguments.get('socket')

    return API(sock_fd, OS_Resource['Socket'], action_num, Resource_Attribute['Null'])


def handle_internet_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None

    if api_name in ('InternetOpenW', 'InternetOpenA'):
        internet_handle = call.get('return_value')
    elif api_name == 'InternetOpenUrlW':
        internet_handle = int(arguments.get('hInternet'), 0)
    else:
        internet_handle = int(arguments.get('internet_handle'), 0)

    return API(internet_handle, OS_Resource['Internet'], action_num, Resource_Attribute['Null'])


def handle_thread_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None

    if api_name == 'CreateThread':
        thread_handle = call.get('return_value')
    else:
        thread_handle = int(arguments.get('thread_handle'), 0)

    return API(thread_handle, OS_Resource['Thread'], action_num, Resource_Attribute['Null'])


def handle_nt_close(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    handle = arguments.get('handle', None)
    if handle is None:
        return None
    return API(handle, OS_Resource['Any'], action_num, Resource_Attribute['Null'])


def add_sequence(all_sequences: list, ns):
    for i in range(len(all_sequences)):
        s = all_sequences[i]
        if s.sequence == ns.sequence and s.resource == ns.resource and s.attribute == ns.attribute:
            all_sequences[i].count += 1
            return
    all_sequences.append(ns)


# Takes a filepath to a cuckoo report file and returns a tuple containing API sequences found.
def process_report(filename: str) -> list:

    # Open cuckoo report file.
    with open(filename, 'r') as cuckoo_report_file:
        try:
            data = json.load(cuckoo_report_file)
        except:
            print(filename + ' -> ERROR PARSING JSON')
            return None

    # Get report behavior section.
    behavior = data.get('behavior')
    if behavior is None:
        print(filename + ' -> NO BEHAVIOR SECTION')
        return None

    # Get report processes section.
    processes = behavior.get('processes')
    if processes is None:
        print(filename + ' -> NO PROCESSES SECTION')
        return None

    # Go through all calls in all processes.
    all_sequences = list()
    for process in processes:

        open_files = dict()
        open_regs = dict()
        open_sockets = dict()
        open_internets = dict()
        open_threads = dict()

        for call in process.get('calls'):
            api_name = call.get('api', None)
            if api_name is None:
                continue
            if is_file_api(api_name):
                api = handle_file_api(call)
                if api is None:
                    continue
                if api.action == 1 or api.action == 2:
                    open_files[api.handle] = API_Sequence([api.action], 1, OS_Resource['File'], api.attribute)
                elif api.handle in open_files:
                    open_files[api.handle].sequence.append(api.action)

            elif is_reg_api(api_name):
                api = handle_reg_api(call)
                if api is None:
                    continue
                if api.action == 1 or api.action == 2:
                    open_regs[api.handle] = API_Sequence([api.action], 1, OS_Resource['RegistryKey'], api.attribute)
                elif (api.action == 5 or api.action == 6) and api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_regs[api.handle])
                    open_regs.pop(api.handle)
                elif api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)

            elif is_nt_close(api_name):
                api = handle_nt_close(call)
                if api is None:
                    continue
                if api.handle in open_files:
                    open_files[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_files[api.handle])
                    open_files.pop(api.handle)
                elif api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_regs[api.handle])
                    open_regs.pop(api.handle)

            elif is_socket_api(api_name):
                api = handle_socket_api(call)
                if api is None:
                    continue
                if api.action == 2: # Create socket
                    open_sockets[api.handle] = API_Sequence([api.action], 1, OS_Resource['Socket'], api.attribute)
                elif api.action == 5 and api.handle in open_sockets: # closesocket
                    open_sockets[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_sockets[api.handle])
                    open_sockets.pop(api.handle)
                elif api.handle in open_sockets:
                    open_sockets[api.handle].sequence.append(api.action)

            elif is_internet_api(api_name):
                api = handle_internet_api(call)
                if api is None:
                    continue
                if api.action == 1: # InternetOpen
                    open_internets[api.handle] = API_Sequence([api.action], 1, OS_Resource['Internet'], api.attribute)
                elif api.action == 5 and api.handle in open_internets: # InternetCloseHandle
                    open_internets[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_internets[api.handle])
                    open_internets.pop(api.handle)
                elif api.handle in open_internets:
                    open_internets[api.handle].sequence.append(api.action)

            elif is_thread_api(api_name):
                api = handle_thread_api(call)
                if api is None:
                    continue
                if api.action in (1, 2): # Create thread
                    open_threads[api.handle] = API_Sequence([api.action], 1, OS_Resource['Thread'], api.attribute)
                elif api.handle in open_threads:
                    open_threads[api.handle].sequence.append(api.action)

        # Add unclosed file sequences.
        for file_handle in list(open_files.keys()):
            add_sequence(all_sequences, open_files[file_handle])
            open_files.pop(file_handle)

        # Add unclosed registry key sequences.
        for key_handle in list(open_regs.keys()):
            add_sequence(all_sequences, open_regs[key_handle])
            open_regs.pop(key_handle)

        # Add unclosed socket sequences.
        for sock_fd in list(open_sockets.keys()):
            add_sequence(all_sequences, open_sockets[sock_fd])
            open_sockets.pop(sock_fd)

        # Add unclosed internet sequences.
        for internet_handle in list(open_internets.keys()):
            add_sequence(all_sequences, open_internets[internet_handle])
            open_internets.pop(internet_handle)

        # Add unclosed thread sequences.
        for thread_handle in list(open_threads.keys()):
            add_sequence(all_sequences, open_threads[thread_handle])
            open_threads.pop(thread_handle)

    return all_sequences


# Goes through all reports in a directory, gets API sequences for each of them, and writes to a
# CSV file.
def process_directory(dir_name: str, verdict: int):
    file_count = 0

    # Randomly iterate through directory files.
    files_paths = [dir_name + f for f in os.listdir(dir_name)]
    for filename in random.sample(files_paths, len(files_paths)):

        if file_count >= MAX_SAMPLES:
            break

        sequences = process_report(filename)
        if sequences is None:
            continue

        # Don't write sequence data to CSV file if not enough.
        num_sequences = 0
        for s in sequences:
            num_sequences += s.count
        if num_sequences < MIN_SEQUENCES:
            print(filename + ' -> NOT ENOUGH DATA')
            continue

        # TODO: Sort sequences?
        # Truncate number of API sequences to maximum amount.
        sequences = sequences[:MAX_SEQUENCES]

        with open(OUTPUT_FILE, 'a') as csvfile:
            csv_writer = csv.writer(csvfile)
            csv_writer.writerow([verdict])
            for s in sequences:
                csv_writer.writerow(get_one_hot_seq(s.sequence) + [s.count] + get_one_hot_resource(s.resource) + get_one_hot_attr(s.attribute))
        file_count += 1
        print(filename + ' -> Success')


# Takes a sequence of numbers, pads/truncates it, and encodes to one hot.
def get_one_hot_seq(sequence: list) -> list:
    sequence = sequence[:MAX_SEQUENCE_LEN]
    for _ in range(MAX_SEQUENCE_LEN - len(sequence)):
        sequence.append(0)
    one_hot_seq = list()
    for action_num in sequence:
        temp_seq = [0] * 29
        if action_num > 0:
            temp_seq[action_num - 1] = 1
        one_hot_seq.extend(temp_seq)
    return one_hot_seq


def get_one_hot_resource(resource: int) -> list:
    one_hot_resource = [0] * NUM_OS_RESOURCES
    if resource > 0:
        one_hot_resource[resource - 1] = 1
    return one_hot_resource


def get_one_hot_attr(attribute: int) -> list:
    one_hot_attr = [0] * NUM_ATTRIBUTES
    if attribute > 0:
        one_hot_attr[attribute - 1] = 1
    return one_hot_attr


def main():
    # Remove current output file so we can append to it.
    if os.path.exists(OUTPUT_FILE):
        os.remove(OUTPUT_FILE)
    process_directory('/Volumes/Data/Malware_Samples/mal_reports/', 1)
    process_directory('/Volumes/Data/Malware_Samples/ben_reports/', 0)
    #process_directory('/home/brandon/mal_reports/', 1)
    #process_directory('/home/brandon/ben_reports/', 0)
    print('Done.')


if __name__ == "__main__":
    main()
