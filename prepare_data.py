import json
import csv
import os

api_encodings = {

    # Files
    'NtWriteFile': 1,
    'SetFileInformationByHandle': 2,
    'GetFileSize': 3,
    'GetFileSizeEx': 3,
    'SetEndOfFile': 4,
    'SetFilePointerEx': 5,
    'GetFileInformationByHandle': 6,
    'GetFileInformationByHandleEx': 6,
    'GetFileType': 7,
    'NtSetInformationFile': 8,
    'NtCreateFile': 9,
    'NtQueryInformationFile': 10,
    'NtDeviceIoControlFile': 11,
    'NtReadFile': 12,
    'SetFilePointer': 13,
    'SetFileTime': 14,
    'NtOpenFile': 15,
    'NtQueryDirectoryFile': 16,
    'NtClose': 17,

    # Registry
    'RegDeleteValueA': 18,
    'RegDeleteValueW': 18,
    'NtDeleteValueKey': 18,
    'RegOpenKeyExW': 19,
    'NtOpenKeyEx': 19,
    'NtOpenKey': 19,
    'RegOpenKeyExA': 19,
    'RegEnumValueA': 20,
    'RegEnumValueW': 20,
    'NtEnumerateValueKey': 20,
    'RegQueryInfoKeyW': 21,
    'RegQueryInfoKeyA': 21,
    'NtQueryKey': 21,
    'RegSetValueExA': 22,
    'RegSetValueExW': 22,
    'NtSetValueKey': 22,
    'RegEnumKeyExW': 23,
    'RegEnumKeyExA': 23,
    'RegEnumKeyW': 23,
    'NtEnumerateKey': 23,
    'RegQueryValueExW': 24,
    'RegQueryValueExA': 24,
    'NtQueryValueKey': 24,
    'NtQueryMultipleValueKey': 24,
    'RegDeleteKeyA': 25,
    'RegDeleteKeyW': 25,
    'NtDeleteKey': 25,
    'RegCreateKeyExA': 26,
    'RegCreateKeyExW': 26,
    'NtCreateKey': 26,
    'RegCloseKey': 27,

    # Socket
    'socket': 28,
    'WSASocketW': 28,
    'WSASocketA': 28,
    'connect': 29,
    'iosctlsocket': 30,
    'setsockopt': 31,
    'getsockname': 32,
    'accept': 33,
    'listen': 34,
    'bind': 35,
    'recv': 36,
    'send': 37,
    'shutdown': 38,
    'closesocket': 39, # NtClose?

    # Internet
    'InternetOpenW': 40,
    'InternetOpenA': 40,
    'InternetSetOptionA': 41,
    'InternetSetOptionW': 41,
    'InternetQueryOptionA': 42,
    'InternetQueryOptionW': 42,
    'InternetConnectA': 43,
    'InternetConenctW': 43,
    'InternetOpenUrlA': 44,
    'InternetOpenUrlW': 44,
    'InternetSetStatusCallback': 45,
    'InternetCloseHandle': 46,

    # HTTP
    'HttpOpenRequestA': 47,
    'HttpOpenRequestW': 47,
    'HttpQueryInfoA': 48,
    'HttpQueryInfoW': 48,
    'HttpSendRequestA': 49,
    'HttpSendRequestExA': 49,
    'HttpSendRequestExW': 49,
    'HttpSendRequestW': 49

    # Possibly more APIs? Directory handles, device drivers, memory
}

# Associates sequences to the number of times it occurs.
sequence_count = dict()

# Associates resource handlers to a list of API calls using it.
open_files = dict()
open_keys  = dict()
open_sockets = dict()
open_internets = dict()
open_https = dict()


def api_to_num(api: str) -> int:
    return api_encodings.get(api, -1)


def is_file_api(api: str) -> bool:
    return api_to_num(api) in range(1, 18)

def is_reg_api(api: str) -> bool:
    return api_to_num(api) in range(17, 28)

def is_socket_api(api: str) -> bool:
    return api_to_num(api) in range(28, 40)

def is_internet_api(api: str) -> bool:
    return api_to_num(api) in range(40, 47)

def is_http_api(api: str) -> bool:
    return api_to_num(api) in range(47, 50)


def handle_file_api(call: dict):
    api = call.get('api')

    # Get file handle.
    if api == 'NtClose':
        file_handle = call.get('arguments').get('handle')
    else:
        file_handle = call.get('arguments').get('file_handle')

    # Open/create file - Start a new sequence.
    if api in ('NtOpenFile', 'NtCreateFile'):
        open_files[file_handle] = [api_to_num(api)]

    # Close file - Save sequence count.
    elif api == 'NtClose' and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))
        if tuple(open_files.get(file_handle)) in sequence_count:
            sequence_count[tuple(open_files.get(file_handle))] += 1
        else:
            sequence_count[tuple(open_files.get(file_handle))] = 1
        open_files.pop(file_handle) # Delete file handler since they are reused.

    # All other file APIs.
    elif api_to_num(api) != -1 and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))


def handle_reg_api(call: dict):
    api = call.get('api')

    # Get key handle.
    if api == 'NtClose':
        key_handle = call.get('arguments').get('handle')
    elif api == 'NtQueryMultipleValueKey':
        key_handle = call.get('arguments').get('KeyHandle')
    else:
        key_handle = call.get('arguments').get('key_handle')

    # Open/create key.
    if api in ('RegOpenKeyExW', 'NtOpenKeyEx', 'RegCreateKeyExA', 'NtOpenKey', 'RegOpenKeyExA', 'RegCreateKeyExW', 'NtCreateKey'):
        open_keys[key_handle] = [api_to_num(api)]

    # Close/delete key.
    elif api in ('RegDeleteKeyW', 'RegDeleteKeyA', 'RegCloseKey', 'NtDeleteKey', 'NtClose') and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))
        if tuple(open_keys.get(key_handle)) in sequence_count:
            sequence_count[tuple(open_keys.get(key_handle))] += 1
        else:
            sequence_count[tuple(open_keys.get(key_handle))] = 1
        open_keys.pop(key_handle)

    # All other registry key APIs.
    elif api_to_num(api) != -1 and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))


def handle_socket_api(call: dict):
    api = call.get('api')

    if api in ('socket', 'WSASocketW', 'WSASocketA'):
        sock_fd = call.get('return_value')
    if api == 'getsockname':
        sock_fd = call.get('arguments').get('s')
    else:
        sock_fd = call.get('arguments').get('socket')

    # New socket descriptor to start sequence.
    if api in ('socket', 'WSASocketW', 'WSASocketA') and sock_fd >= 0:
        open_sockets[sock_fd] = [api_to_num(api)]

    # Close socket ends sequence.
    elif api == 'closesocket' and sock_fd in open_sockets:
        open_sockets[sock_fd].append(api_to_num(api))
        if tuple(open_sockets.get(sock_fd)) in sequence_count:
            sequence_count[tuple(open_sockets.get(sock_fd))] += 1
        else:
            sequence_count[tuple(open_sockets.get(sock_fd))] = 1
        open_sockets.pop(sock_fd)

    # All other socket APIs.
    elif api_to_num(api) != -1 and sock_fd in open_sockets:
        open_sockets[sock_fd].append(api_to_num(api))


def handle_internet_api(call: dict):
    api_name = call.get('api')
    api_num  = api_to_num(api_name)

    # Get internet handle.
    if api_name in ('InternetOpenW', 'InternetOpenA'):
        internet_handle = call.get('return_value')
    elif api_name == 'InternetOpenUrlW':
        internet_handle = int(call.get('arguments').get('hInternet'), 0) # Convert from hex to dec
    else:
        internet_handle = int(call.get('arguments').get('internet_handle'), 0)

    if api_name in ('InternetOpenW', 'InternetOpenA'):
        open_internets[internet_handle] = [api_num]

    elif api_name == 'InternetCloseHandle' and internet_handle in open_internets:
        open_internets[internet_handle].append(api_num)
        if tuple(open_internets.get(internet_handle)) in sequence_count:
            sequence_count[tuple(open_internets.get(internet_handle))] += 1
        else:
            sequence_count[tuple(open_internets.get(internet_handle))] = 1
        open_internets.pop(internet_handle)

    elif api_num != -1 and internet_handle in open_internets:
        open_internets[internet_handle].append(api_num)


def handle_http_api(call: dict):
    api_name = call.get('api')
    api_num  = api_to_num(api_name)

    # Get HTTP request handle.
    if api_name in ('HttpOpenRequestA', 'HttpOpenRequestW'):
        http_handle = call.get('return_value')
    else:
        http_handle = int(call.get('arguments').get('request_handle'), 0)

    if api_name in ('HttpOpenRequestA', 'HttpOpenRequestW'):
        open_https[http_handle] = [api_num]
    elif api_num != -1 and http_handle in open_https:
        open_https[http_handle].append(api_num)


def process_reports(dir_name: str, out_name: str, verdict: int):
    count = 0
    for filename in os.listdir(dir_name):
        with open(dir_name + '/' + filename, 'r') as cuckoo_report_file:

            # Create output CSV file.
            output_filename = 'output/' + out_name + '_' + str(count) + '.csv'
            print(filename + ' -> ' + output_filename)
            output_file = open(output_filename, 'w')
            csv_writer = csv.writer(output_file)
            csv_writer.writerow([verdict]) # First line is 1 or 0 to indicate malicious or not.

            data = json.load(cuckoo_report_file)

            behavior = data.get('behavior')
            if behavior is None:
                continue

            processes = behavior.get('processes')
            if processes is None:
                continue

            for p in processes:
                for call in p.get('calls'):
                    api = call.get('api')
                    if is_file_api(api):
                        handle_file_api(call)
                    elif is_reg_api(api):
                        handle_reg_api(call)
                    elif is_socket_api(api):
                        handle_socket_api(call)
                    elif is_internet_api(api):
                        handle_internet_api(call)
                    elif is_http_api(api):
                        handle_http_api(call)

                # We want to save sequences even though the resource was not explicitly closed at
                # the end of every process because resource handlers may be reused across processes.

                # Unclosed files.
                for file_handle in list(open_files.keys()):
                    if tuple(open_files.get(file_handle)) in sequence_count:
                        sequence_count[tuple(open_files.get(file_handle))] += 1
                    else:
                        sequence_count[tuple(open_files.get(file_handle))] = 1
                    open_files.pop(file_handle)

                # Unclosed registry keys.
                for key_handle in list(open_keys.keys()):
                    if tuple(open_keys.get(key_handle)) in sequence_count:
                        sequence_count[tuple(open_keys.get(key_handle))] += 1
                    else:
                        sequence_count[tuple(open_keys.get(key_handle))] = 1
                    open_keys.pop(key_handle)

                # Unclosed sockets.
                for sock_fd in list(open_sockets.keys()):
                    if tuple(open_sockets.get(sock_fd)) in sequence_count:
                        sequence_count[tuple(open_sockets.get(sock_fd))] += 1
                    else:
                        sequence_count[tuple(open_sockets.get(sock_fd))] = 1
                    open_sockets.pop(sock_fd)

                # Unclosed internet handles.
                for internet_handle in list(open_internets.keys()):
                    if tuple(open_internets.get(internet_handle)) in sequence_count:
                        sequence_count[tuple(open_internets.get(internet_handle))] += 1
                    else:
                        sequence_count[tuple(open_internets.get(internet_handle))] = 1
                    open_internets.pop(internet_handle)

                for http_handle in list(open_https.keys()):
                    if tuple(open_https.get(http_handle)) in sequence_count:
                        sequence_count[tuple(open_https.get(http_handle))] += 1
                    else:
                        sequence_count[tuple(open_https.get(http_handle))] = 1
                    open_https.pop(http_handle)

            # Save each sequence with its corresponding count to a CSV.
            for sequence in sequence_count:
                entry = [list(sequence), sequence_count[sequence]]
                csv_writer.writerow(entry)

            sequence_count.clear() # Reset for the next report.
            output_file.close()
            count = count + 1


def main():
    process_reports('malign_reports', 'm', 1)
    process_reports('benign_reports', 'b', 0)
    print("Done.")


if __name__ == "__main__":
    main()
