import json
import csv
import os
import random

OUTPUT_FOLDER = '/Volumes/Data/Malware_Samples/output/'
MAX_OUTPUT_FILES = 200 # May be lower if contains faulty report files.
MAX_SEQUENCE_LEN = 10

api_encodings = {

    # Files
    'NtWriteFile': 1,
    'SetFileInformationByHandle': 2,
    'GetFileSize': 3,
    'GetFileSizeEx': 3,
    'SetEndOfFile': 4,
    'SetFilePointerEx': 5,
    'GetFileInformationByHandle': 6,
    'GetFileInformationByHandleEx': 6,
    'GetFileType': 7,
    'NtSetInformationFile': 8,
    'NtCreateFile': 9,
    'NtQueryInformationFile': 10,
    'NtDeviceIoControlFile': 11,
    'NtReadFile': 12,
    'SetFilePointer': 13,
    'SetFileTime': 14,
    'NtOpenFile': 15,
    'NtQueryDirectoryFile': 16,
    'NtClose': 17,

    # Registry
    'RegDeleteValueA': 18,
    'RegDeleteValueW': 18,
    'NtDeleteValueKey': 18,
    'RegOpenKeyExW': 19,
    'NtOpenKeyEx': 19,
    'NtOpenKey': 19,
    'RegOpenKeyExA': 19,
    'RegEnumValueA': 20,
    'RegEnumValueW': 20,
    'NtEnumerateValueKey': 20,
    'RegQueryInfoKeyW': 21,
    'RegQueryInfoKeyA': 21,
    'NtQueryKey': 21,
    'RegSetValueExA': 22,
    'RegSetValueExW': 22,
    'NtSetValueKey': 22,
    'RegEnumKeyExW': 23,
    'RegEnumKeyExA': 23,
    'RegEnumKeyW': 23,
    'NtEnumerateKey': 23,
    'RegQueryValueExW': 24,
    'RegQueryValueExA': 24,
    'NtQueryValueKey': 24,
    'NtQueryMultipleValueKey': 24,
    'RegDeleteKeyA': 25,
    'RegDeleteKeyW': 25,
    'NtDeleteKey': 25,
    'RegCreateKeyExA': 26,
    'RegCreateKeyExW': 26,
    'NtCreateKey': 26,
    'RegCloseKey': 27,

    # Socket
    'socket': 28,
    'WSASocketW': 28,
    'WSASocketA': 28,
    'connect': 29,
    'iosctlsocket': 30,
    'setsockopt': 31,
    'getsockname': 32,
    'accept': 33,
    'listen': 34,
    'bind': 35,
    'recv': 36,
    'send': 37,
    'shutdown': 38,
    'closesocket': 39,

    # Internet
    'InternetOpenW': 40,
    'InternetOpenA': 40,
    'InternetSetOptionA': 41,
    'InternetSetOptionW': 41,
    'InternetQueryOptionA': 42,
    'InternetQueryOptionW': 42,
    'InternetConnectA': 43,
    'InternetConenctW': 43,
    'InternetOpenUrlA': 44,
    'InternetOpenUrlW': 44,
    'InternetSetStatusCallback': 45,
    'InternetCloseHandle': 46,

    # HTTP
    'HttpOpenRequestA': 47,
    'HttpOpenRequestW': 47,
    'HttpQueryInfoA': 48,
    'HttpQueryInfoW': 48,
    'HttpSendRequestA': 49,
    'HttpSendRequestExA': 49,
    'HttpSendRequestExW': 49,
    'HttpSendRequestW': 49,

    # Threads
    'CreateThread': 50,
    'NtCreateThreadEx': 50,
    'RtlCreateUserThread': 50,
    'NtOpenThread': 51,
    'NtSuspendThread': 52,
    'NtResumeThread': 53,
    'NtGetContextThread': 54,
    'NtSetContextThread': 55,
    'NtQueueApcThread': 56
}

# Associates sequences to the number of times it occurs.
sequence_count = dict()

# Associates resource handlers to a list of API calls using it.
open_files     = dict()
open_keys      = dict()
open_sockets   = dict()
open_internets = dict()
open_https     = dict()
open_threads   = dict()


def api_to_num(api: str) -> int:
    return api_encodings.get(api, -1)


def is_file_api(api: str) -> bool:
    return api_to_num(api) in range(1, 18)

def is_reg_api(api: str) -> bool:
    return api_to_num(api) in range(17, 28)

def is_socket_api(api: str) -> bool:
    return api_to_num(api) in range(28, 40)

def is_internet_api(api: str) -> bool:
    return api_to_num(api) in range(40, 47)

def is_http_api(api: str) -> bool:
    return api_to_num(api) in range(47, 50)

def is_thread_api(api: str) -> bool:
    return api_to_num(api) in range(50, 57)


def handle_file_api(call: dict):
    api = call.get('api')

    # Get file handle.
    if api == 'NtClose':
        file_handle = call.get('arguments').get('handle')
    else:
        file_handle = call.get('arguments').get('file_handle')

    # Open/create file - Start a new sequence.
    if api in ('NtOpenFile', 'NtCreateFile'):
        open_files[file_handle] = [api_to_num(api)]

    # Close file - Save sequence count.
    elif api == 'NtClose' and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))
        if tuple(open_files.get(file_handle)) in sequence_count:
            sequence_count[tuple(open_files.get(file_handle))] += 1
        else:
            sequence_count[tuple(open_files.get(file_handle))] = 1
        open_files.pop(file_handle) # Delete file handler since they are reused.

    # All other file APIs.
    elif api_to_num(api) != -1 and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))


def handle_reg_api(call: dict):
    api = call.get('api')

    # Get key handle.
    if api == 'NtClose':
        key_handle = call.get('arguments').get('handle')
    elif api == 'NtQueryMultipleValueKey':
        key_handle = call.get('arguments').get('KeyHandle')
    else:
        key_handle = call.get('arguments').get('key_handle')

    # Open/create key.
    if api in ('RegOpenKeyExW', 'NtOpenKeyEx', 'RegCreateKeyExA', 'NtOpenKey', 'RegOpenKeyExA', 'RegCreateKeyExW', 'NtCreateKey'):
        open_keys[key_handle] = [api_to_num(api)]

    # Close/delete key.
    elif api in ('RegDeleteKeyW', 'RegDeleteKeyA', 'RegCloseKey', 'NtDeleteKey', 'NtClose') and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))
        if tuple(open_keys.get(key_handle)) in sequence_count:
            sequence_count[tuple(open_keys.get(key_handle))] += 1
        else:
            sequence_count[tuple(open_keys.get(key_handle))] = 1
        open_keys.pop(key_handle)

    # All other registry key APIs.
    elif api_to_num(api) != -1 and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))


def handle_socket_api(call: dict):
    api = call.get('api')

    if api in ('socket', 'WSASocketW', 'WSASocketA'):
        sock_fd = call.get('return_value')
    if api == 'getsockname':
        sock_fd = call.get('arguments').get('s')
    else:
        sock_fd = call.get('arguments').get('socket')

    # New socket descriptor to start sequence.
    if api in ('socket', 'WSASocketW', 'WSASocketA') and sock_fd >= 0:
        open_sockets[sock_fd] = [api_to_num(api)]

    # Close socket ends sequence.
    elif api == 'closesocket' and sock_fd in open_sockets:
        open_sockets[sock_fd].append(api_to_num(api))
        if tuple(open_sockets.get(sock_fd)) in sequence_count:
            sequence_count[tuple(open_sockets.get(sock_fd))] += 1
        else:
            sequence_count[tuple(open_sockets.get(sock_fd))] = 1
        open_sockets.pop(sock_fd)

    # All other socket APIs.
    elif api_to_num(api) != -1 and sock_fd in open_sockets:
        open_sockets[sock_fd].append(api_to_num(api))


def handle_internet_api(call: dict):
    api_name = call.get('api')
    api_num  = api_to_num(api_name)

    # Get internet handle.
    if api_name in ('InternetOpenW', 'InternetOpenA'):
        internet_handle = call.get('return_value')
    elif api_name == 'InternetOpenUrlW':
        internet_handle = int(call.get('arguments').get('hInternet'), 0) # Convert from hex to dec
    else:
        internet_handle = int(call.get('arguments').get('internet_handle'), 0)

    if api_name in ('InternetOpenW', 'InternetOpenA'):
        open_internets[internet_handle] = [api_num]

    elif api_name == 'InternetCloseHandle' and internet_handle in open_internets:
        open_internets[internet_handle].append(api_num)
        if tuple(open_internets.get(internet_handle)) in sequence_count:
            sequence_count[tuple(open_internets.get(internet_handle))] += 1
        else:
            sequence_count[tuple(open_internets.get(internet_handle))] = 1
        open_internets.pop(internet_handle)

    elif api_num != -1 and internet_handle in open_internets:
        open_internets[internet_handle].append(api_num)


def handle_http_api(call: dict):
    api_name = call.get('api')
    api_num  = api_to_num(api_name)

    # Get HTTP request handle.
    if api_name in ('HttpOpenRequestA', 'HttpOpenRequestW'):
        http_handle = call.get('return_value')
    else:
        http_handle = int(call.get('arguments').get('request_handle'), 0)

    if api_name in ('HttpOpenRequestA', 'HttpOpenRequestW'):
        open_https[http_handle] = [api_num]
    elif api_num != -1 and http_handle in open_https:
        open_https[http_handle].append(api_num)


def handle_thread_api(call: dict):
    api_name = call.get('api')
    api_num  = api_to_num(api_name)

    # Get thread handle.
    if api_name in ('CreateThread'):
        thread_handle = call.get('return_value')
    else:
        thread_handle = int(call.get('arguments').get('thread_handle'), 0)

    if api_name in ('CreateThread', 'NtCreateThreadEx', 'RtlCreateUserThread'):
        open_threads[thread_handle] = [api_num]
    elif api_num != -1 and thread_handle in open_threads:
        open_threads[thread_handle].append(api_num)


def process_unclosed_handles(open_handles: dict):
    for handle in list(open_handles.keys()):
        if tuple(open_handles.get(handle)) in sequence_count:
            sequence_count[tuple(open_handles.get(handle))] += 1
        else:
            sequence_count[tuple(open_handles.get(handle))] = 1
        open_handles.pop(handle)


def process_reports(dir_name: str, out_name: str, verdict: int):

    filecount = 0

    for filename in random.sample(os.listdir(dir_name), len(os.listdir(dir_name))):

        if filecount >= MAX_OUTPUT_FILES:
            break

        # Create output CSV file.
        output_filename = OUTPUT_FOLDER + out_name + '_' + str(filecount) + '.csv'
        output_file = open(output_filename, 'w')
        csv_writer = csv.writer(output_file)
        csv_writer.writerow([verdict]) # First line is 1 or 0 to indicate malicious or not.

        with open(dir_name + filename, 'r') as cuckoo_report_file:
            try:
                data = json.load(cuckoo_report_file)
            except:
                print(filename + ' -> ERROR PARSING JSON')
                continue

        behavior = data.get('behavior')
        if behavior is None:
            print(filename + ' -> NO BEHAVIOR SECTION')
            continue

        processes = behavior.get('processes')
        if processes is None:
            print(filename + ' -> NO PROCESSES SECTION')
            continue

        for p in processes:
            for call in p.get('calls'):
                api = call.get('api')
                if is_file_api(api):
                    handle_file_api(call)
                if is_reg_api(api):
                    handle_reg_api(call)
                if is_socket_api(api):
                    handle_socket_api(call)
                if is_internet_api(api):
                    handle_internet_api(call)
                if is_http_api(api):
                    handle_http_api(call)
                if is_thread_api(api):
                    handle_thread_api(call)

            # We want to save sequences even though the resource was not explicitly closed at
            # the end of every process because resource handlers may be reused across processes.

            process_unclosed_handles(open_files)
            process_unclosed_handles(open_keys)
            process_unclosed_handles(open_sockets)
            process_unclosed_handles(open_internets)
            process_unclosed_handles(open_https)
            process_unclosed_handles(open_threads)

        if len(sequence_count) == 0:
            print(filename + ' -> NO SEQUENCES')
            continue

        print(filename + ' -> ' + output_filename)

        # Save each sequence with its corresponding count to a CSV.
        for sequence in sequence_count:
            count = sequence_count[sequence]

            # Pad/truncate each sequence to specified length.
            sequence = list(sequence)[:MAX_SEQUENCE_LEN]
            while len(sequence) < MAX_SEQUENCE_LEN:
                sequence.append(0)

            csv_writer.writerow([sequence, count])

        sequence_count.clear() # Reset for the next report.
        output_file.close()
        filecount += 1


def main():
    process_reports('/Volumes/Data/Malware_Samples/mal_reports/', 'm', 1)
    process_reports('/Volumes/Data/Malware_Samples/ben_reports/', 'b', 0)
    print("Done.")


if __name__ == "__main__":
    main()
