import csv
import json
import os
import random
from dataclasses import dataclass

OUTPUT_FILE = '/Volumes/Data/Malware_Samples/data.csv'
MAX_SEQUENCE_LEN = 10
MIN_SEQUENCES = 5
MAX_SEQUENCES = 75


@dataclass
class API:
    handle: int
    resource: int
    action: int
    attribute: int = 0


@dataclass
class API_Sequence:
    sequence: list
    count: int = 0
    resource: int = 0
    attribute: int = 0


OS_Resource = {
    'Any': 0,
    'File': 1,
    'RegistryKey': 2,
    'Thread': 3,
    'Socket': 4,
    'Internet': 5,
    'HTTP': 6
}


Resource_Attribute = {
    'Null': 0,
    'UserFile': 1,
    'SystemFile': 2,
    'HKEY_CLASSES_ROOT': 3,
    'HKEY_CURRENT_USER': 4,
    'HKEY_LOCAL_MACHINE': 5,
    'HKEY_USERS': 6,
    'HKEY_CURRENT_CONFIG': 7
}

'''
ACTIONS:
    1. Open
    2. Create
    3. Read
    4. Write
    5. Close
    6. Delete Resource
    7. Suspend
    8. Resume
    9. Set Information
    10. Get Information
    11. Get Size
    12. Set End
    13. Set Pointer
    14. Get Type
    15. Set Time
    16. Delete Value
    17. Enumerate Values
    18. Set Value
    19. Enumerate Keys
    20. Get Value
    Connect Socket
    Control Socket I/O
    Set Socket Option
    Get Socket Name
    Accept Connection
    Listen for Connection
    Socket Bind
    Socket Receive
    Socket Send
    Socket Shutdown

NOTES:
    Open Keys (arguments.regkey)
'''

FILE_APIS = ('NtWriteFile', 'SetFileInformationByHandle', 'GetFileSize', 'GetFileSizeEx',
    'SetEndOfFile', 'SetFilePointerEx', 'GetFileInformationByHandle', 'GetFileInformationByHandleEx',
    'GetFileType', 'NtSetInformationFile', 'NtCreateFile', 'NtQueryInformationFile',
    'NtDeviceIoControlFile', 'NtReadFile', 'SetFilePointer', 'SetFileTime', 'NtOpenFile',
    'NtQueryDirectoryFile')

REG_APIS = ('RegDeleteValueA', 'RegDeleteValueW', 'NtDeleteValueKey', 'RegOpenKeyExW', 'NtOpenKeyEx',
    'NtOpenKey', 'RegOpenKeyExA', 'RegEnumValueA', 'RegEnumValueW', 'NtEnumerateValueKey',
    'RegQueryInfoKeyW', 'RegQueryInfoKeyA', 'NtQueryKey', 'RegSetValueExA', 'RegSetValueExW',
    'NtSetValueKey', 'RegEnumKeyExW', 'RegEnumKeyExA', 'RegEnumKeyW', 'NtEnumerateKey',
    'RegQueryValueExW', 'RegQueryValueExA', 'NtQueryValueKey', 'NtQueryMultipleValueKey', 'RegDeleteKeyA',
    'RegDeleteKeyW', 'NtDeleteKey', 'RegCreateKeyExA', 'RegCreateKeyExW', 'NtCreateKey', 'RegCloseKey')

API_ACTIONS = {
    **dict.fromkeys(['NtOpenFile', 'RegOpenKeyExW', 'NtOpenKeyEx', 'NtOpenKey', 'RegOpenKeyExA'], 1),
    **dict.fromkeys(['NtCreateFile', 'RegCreateKeyExA', 'RegCreateKeyExW', 'NtCreateKey'], 2),
    **dict.fromkeys(['NtReadFile'], 3),
    **dict.fromkeys(['NtWriteFile', 'NtDeviceIoControlFile'], 4),
    **dict.fromkeys(['NtClose', 'RegCloseKey'], 5),
    **dict.fromkeys(['RegDeleteKeyA', 'RegDeleteKeyW', 'NtDeleteKey'], 6),
    # **dict.fromkeys([''], 7),
    # **dict.fromkeys([''], 8),
    **dict.fromkeys(['NtSetInformationFile', 'SetFileInformationByHandle'], 9),
    **dict.fromkeys(['NtQueryInformationFile', 'NtQueryDirectoryFile', 'GetFileInformationByHandle', 'GetFileInformationByHandleEx', 'RegQueryInfoKeyW', 'RegQueryInfoKeyA', 'NtQueryKey'], 10),
    **dict.fromkeys(['GetFileSize', 'GetFileSizeEx'], 11),
    **dict.fromkeys(['SetEndOfFile'], 12),
    **dict.fromkeys(['SetFilePointer', 'SetFilePointerEx'], 13),
    **dict.fromkeys(['GetFileType'], 14),
    **dict.fromkeys(['SetFileTime'], 15),
    **dict.fromkeys(['RegDeleteValueA', 'RegDeleteValueW', 'NtDeleteValueKey'], 16),
    **dict.fromkeys(['RegEnumValueA', 'RegEnumValueW', 'NtEnumerateValueKey'], 17),
    **dict.fromkeys(['RegSetValueExA', 'RegSetValueExW', 'NtSetValueKey'], 18),
    **dict.fromkeys(['RegEnumKeyExW', 'RegEnumKeyExA', 'RegEnumKeyW', 'NtEnumerateKey'], 19),
    **dict.fromkeys(['RegQueryValueExW', 'RegQueryValueExA', 'NtQueryValueKey', 'NtQueryMultipleValueKey'], 20)
}


def get_action_num(api_name: str) -> int:
    return API_ACTIONS.get(api_name, -1)


def is_file_api(api_name: str) -> bool:
    return api_name in FILE_APIS


def is_reg_api(api_name: str) -> bool:
    return api_name in REG_APIS


# Special because NtClose can be used on multiple handles (file, reg keys, etc.)
def is_nt_close(api_name: str) -> bool:
    return api_name == 'NtClose'


def handle_file_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    file_handle = arguments.get('file_handle', None)
    if file_handle is None:
        return None

    if action_num == 1 or action_num == 2:
        filename = arguments.get('filepath', None)
        if 'System32' in filename or 'SysWOW64' in filename:
            attribute = Resource_Attribute['SystemFile']
        else:
            attribute = Resource_Attribute['UserFile']
        return API(file_handle, OS_Resource['File'], action_num, attribute)
    else:
        return API(file_handle, OS_Resource['File'], action_num, Resource_Attribute['Null'])


def handle_reg_api(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    if api_name == 'NtQueryMultipleValueKey':
        key_handle = arguments.get('KeyHandle')
    else:
        key_handle = arguments.get('key_handle', None)
    if key_handle is None:
        return None

    attribute = Resource_Attribute['Null']
    if action_num == 1 or action_num == 2:
        key_name = arguments.get('regkey', None)
        if 'HKEY_CLASSES_ROOT' in key_name:
            attribute = Resource_Attribute['HKEY_CLASSES_ROOT']
        elif 'HKEY_CURRENT_USER' in key_name:
            attribute = Resource_Attribute['HKEY_CURRENT_USER']
        elif 'HKEY_LOCAL_MACHINE' in key_name:
            attribute = Resource_Attribute['HKEY_LOCAL_MACHINE']
        elif 'HKEY_USERS' in key_name:
            attribute = Resource_Attribute['HKEY_USERS']
        elif 'HKEY_CURRENT_CONFIG' in key_name:
            attribute = Resource_Attribute['HKEY_CURRENT_CONFIG']

    return API(key_handle, OS_Resource['RegistryKey'], action_num, attribute)


def handle_nt_close(call: dict) -> API:
    api_name = call.get('api', None)
    if api_name is None:
        return None
    action_num = get_action_num(api_name)
    if action_num == -1:
        return None
    arguments = call.get('arguments', None)
    if arguments is None:
        return None
    file_handle = arguments.get('handle', None)
    if file_handle is None:
        return None
    return API(file_handle, OS_Resource['Any'], action_num, Resource_Attribute['Null'])


def add_sequence(all_sequences: list, ns):
    for i in range(len(all_sequences)):
        s = all_sequences[i]
        if s.sequence == ns.sequence and s.resource == ns.resource and s.attribute == ns.attribute:
            all_sequences[i].count += 1
            return
    all_sequences.append(ns)


# Takes a filepath to a cuckoo report file and returns a tuple containing API sequences found.
def process_report(filename: str) -> list:

    # Open cuckoo report file.
    with open(filename, 'r') as cuckoo_report_file:
        try:
            data = json.load(cuckoo_report_file)
        except:
            print(filename + ' -> ERROR PARSING JSON')
            return None

    # Get report behavior section.
    behavior = data.get('behavior')
    if behavior is None:
        print(filename + ' -> NO BEHAVIOR SECTION')
        return None

    # Get report processes section.
    processes = behavior.get('processes')
    if processes is None:
        print(filename + ' -> NO PROCESSES SECTION')
        return None

    # Go through all calls in all processes.
    all_sequences = list()
    for process in processes:

        open_files = dict()
        open_regs  = dict()

        for call in process.get('calls'):
            api_name = call.get('api', None)
            if api_name is None:
                continue
            if is_file_api(api_name):
                api = handle_file_api(call)
                if api is None:
                    continue
                if api.action == 1 or api.action == 2:
                    open_files[api.handle] = API_Sequence([api.action], 1, OS_Resource['File'], api.attribute)
                elif api.handle in open_files:
                    open_files[api.handle].sequence.append(api.action)

            elif is_reg_api(api_name):
                api = handle_reg_api(call)
                if api is None:
                    continue
                if api.action == 1 or api.action == 2:
                    open_regs[api.handle] = API_Sequence([api.action], 1, OS_Resource['RegistryKey'], api.attribute)
                elif (api.action == 5 or api.action == 6) and api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_regs[api.handle])
                    open_regs.pop(api.handle)
                elif api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)

            elif is_nt_close(api_name):
                api = handle_nt_close(call)
                if api is None:
                    continue
                if api.handle in open_files:
                    open_files[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_files[api.handle])
                    open_files.pop(api.handle)
                elif api.handle in open_regs:
                    open_regs[api.handle].sequence.append(api.action)
                    add_sequence(all_sequences, open_regs[api.handle])
                    open_regs.pop(api.handle)

        # Add unclosed file sequences.
        for file_handle in list(open_files.keys()):
            add_sequence(all_sequences, open_files[file_handle])
            open_files.pop(file_handle)

        for key_handle in list(open_regs.keys()):
            add_sequence(all_sequences, open_regs[key_handle])
            open_regs.pop(key_handle)

    return all_sequences


# Goes through all reports in a directory, gets API sequences for each of them, and writes to a
# CSV file.
def process_directory(dir_name: str, verdict: int):

    # Randomly iterate through directory files.
    files_paths = [dir_name + f for f in os.listdir(dir_name)]
    for filename in random.sample(files_paths, len(files_paths)):
        sequences = process_report(filename)
        write_to_csv(filename, sequences, verdict)


# Takes a sequence of numbers and pads/truncates it to specified length.
def pad_sequence(sequence: list) -> list:
    sequence = sequence[:MAX_SEQUENCE_LEN]
    for _ in range(MAX_SEQUENCE_LEN - len(sequence)):
        sequence.append(0)
    return sequence


def write_to_csv(filename: str, sequences: list, verdict: int):
    if sequences is None:
        print(filename + ' -> BAD SEQUENCE ARGUMENT')
        return

    # Don't write sequence data to CSV file if not enough.
    num_sequences = 0
    for s in sequences:
        num_sequences += s.count
    if num_sequences < MIN_SEQUENCES:
        print(filename + ' -> NOT ENOUGH DATA')
        return

    with open(OUTPUT_FILE, 'a') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow([verdict])
        for s in sequences:
            csv_writer.writerow([s.count, s.resource, s.attribute, pad_sequence(s.sequence)])
    print(filename + ' -> Success')


def main():

    # Remove current output file so we can append to it.
    if os.path.exists(OUTPUT_FILE):
        os.remove(OUTPUT_FILE)
    process_directory('/Volumes/Data/Malware_Samples/test_reports/', 1)
    # process_reports('/Volumes/Data/Malware_Samples/ben_reports/', 0)
    print("Done.")


if __name__ == "__main__":
    main()
