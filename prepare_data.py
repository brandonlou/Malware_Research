import json
import csv
import os

api_encodings = {

    # Files
    'NtWriteFile': 1,
    'SetFileInformationByHandle': 2,
    'GetFileSize': 3,
    'SetEndOfFile': 4,
    'SetFilePointerEx': 5,
    'GetFileInformationByHandleEx': 6,
    'GetFileType': 7,
    'NtSetInformationFile': 8,
    'NtCreateFile': 9,
    'NtQueryInformationFile': 10,
    'NtDeviceIoControlFile': 11,
    'NtReadFile': 12,
    'SetFilePointer': 13,
    'GetFileInformationByHandle': 14,
    'SetFileTime': 15,
    'NtOpenFile': 16,
    'GetFileSizeEx': 17,
    'NtQueryDirectoryFile': 18,
    'NtClose': 19,

    # Registry
    'RegDeleteValueA': 20,
    'RegOpenKeyExW': 21,
    'RegEnumValueA': 22,
    'RegQueryInfoKeyW': 23,
    'RegSetValueExA': 24,
    'RegEnumKeyExA': 25,
    'RegQueryValueExA': 26,
    'RegDeleteValueW': 27,
    'RegEnumKeyW': 28,
    'NtOpenKeyEx': 29,
    'RegSetValueExW': 30,
    'RegDeleteKeyW': 31,
    'RegCreateKeyExA': 32,
    'NtSetValueKey': 33,
    'NtDeleteValueKey': 34,
    'NtQueryMultipleValueKey': 35,
    'NtOpenKey': 36,
    'RegOpenKeyExA': 37,
    'RegEnumValueW': 38,
    'RegQueryInfoKeyA': 39,
    'NtEnumerateKey': 40,
    'NtQueryValueKey': 41,
    'RegCreateKeyExW': 42,
    'RegQueryValueExW': 43,
    'NtCreateKey': 44,
    'RegCloseKey': 45,
    'NtDeleteKey': 46,
    'RegEnumKeyExW': 47,
    'NtQueryKey': 48,
    'NtEnumerateValueKey': 49,
    'RegDeleteKeyA': 50

    # Possibly more APIs? Directory handles, device drivers, memory
}

# Associates sequences to the number of times it occurs.
sequence_count = dict()

# Associates file/key handlers to a list of API calls using it.
open_files = dict()
open_keys  = dict()


def api_to_num(api: str) -> int:
    return api_encodings.get(api, -1)


def is_file_api(api: str) -> bool:
    return api_to_num(api) in range(1, 20)


def is_reg_api(api:str) -> bool:
    return api_to_num(api) in range(19, 51)


def handle_file_api(call: dict):
    api = call.get('api')

    # Get file handle.
    if api == 'NtClose':
        file_handle = call.get('arguments').get('handle')
    else:
        file_handle = call.get('arguments').get('file_handle')

    # Open/create file - Start a new sequence.
    if api in ('NtOpenFile', 'NtCreateFile'):
        open_files[file_handle] = [api_to_num(api)]

    # Close file - Save sequence count.
    elif api == 'NtClose' and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))
        if tuple(open_files.get(file_handle)) in sequence_count:
            sequence_count[tuple(open_files.get(file_handle))] = sequence_count[tuple(open_files.get(file_handle))] + 1
        else:
            sequence_count[tuple(open_files.get(file_handle))] = 1
        open_files.pop(file_handle) # Delete file handler since they are reused.

    # All other file APIs.
    elif api_to_num(api) != -1 and file_handle in open_files:
        open_files.get(file_handle).append(api_to_num(api))


def handle_reg_api(call: dict):
    api = call.get('api')

    # Get key handle.
    if api == 'NtClose':
        key_handle = call.get('arguments').get('handle')
    elif api == 'NtQueryMultipleValueKey':
        key_handle = call.get('arguments').get('KeyHandle')
    else:
        key_handle = call.get('arguments').get('key_handle')

    # Open/create key.
    if api in ('RegOpenKeyExW', 'NtOpenKeyEx', 'RegCreateKeyExA', 'NtOpenKey', 'RegOpenKeyExA', 'RegCreateKeyExW', 'NtCreateKey'):
        open_keys[key_handle] = [api_to_num(api)]

    # Close/delete key.
    elif api in ('RegDeleteKeyW', 'RegDeleteKeyA', 'RegCloseKey', 'NtDeleteKey', 'NtClose') and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))
        if tuple(open_keys.get(key_handle)) in sequence_count:
            sequence_count[tuple(open_keys.get(key_handle))] = sequence_count[tuple(open_keys.get(key_handle))] + 1
        else:
            sequence_count[tuple(open_keys.get(key_handle))] = 1
        open_keys.pop(key_handle)

    # All other registry key APIs.
    elif api_to_num(api) != -1 and key_handle in open_keys:
        open_keys.get(key_handle).append(api_to_num(api))


def process_reports(dir_name: str, out_name: str, verdict: int):
    count = 0
    for filename in os.listdir(dir_name):
        with open(dir_name + '/' + filename, 'r') as cuckoo_report_file:

            # Create output CSV file.
            output_filename = 'output/' + out_name + '_' + str(count) + '.csv'
            print(filename + ' -> ' + output_filename)
            output_file = open(output_filename, 'w')
            csv_writer = csv.writer(output_file)
            csv_writer.writerow([verdict]) # First line is 1 or 0 to indicate malicious or not.

            data = json.load(cuckoo_report_file)

            behavior = data.get('behavior')
            if behavior is None:
                continue

            processes = behavior.get('processes')
            if processes is None:
                continue

            for p in processes:
                for call in p.get('calls'):
                    api = call.get('api')
                    if is_file_api(api):
                        handle_file_api(call)
                    elif is_reg_api(api):
                        handle_reg_api(call)

            # Make sure unclosed files still in the open files list are added to the global sequence count.
            for file_handle in list(open_files.keys()):
                if tuple(open_files.get(file_handle)) in sequence_count:
                    sequence_count[tuple(open_files.get(file_handle))] = sequence_count[tuple(open_files.get(file_handle))] + 1
                else:
                    sequence_count[tuple(open_files.get(file_handle))] = 1
                open_files.pop(file_handle)

            # Unclosed registry keys.
            for key_handle in list(open_keys.keys()):
                if tuple(open_keys.get(key_handle)) in sequence_count:
                    sequence_count[tuple(open_keys.get(key_handle))] = sequence_count[tuple(open_keys.get(key_handle))] + 1
                else:
                    sequence_count[tuple(open_keys.get(key_handle))] = 1
                open_keys.pop(key_handle)

            # Save each sequence with its corresponding count to a CSV.
            for sequence in sequence_count:
                entry = [list(sequence), sequence_count[sequence]]
                csv_writer.writerow(entry)

            sequence_count.clear() # Reset for the next report.
            output_file.close()
            count = count + 1


def main():
    process_reports('malign_reports', 'm', 1)
    process_reports('benign_reports', 'b', 0)
    print("Done.")


if __name__ == "__main__":
    main()
