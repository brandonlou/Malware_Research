import os
import sys
import math
from collections import Counter


# Takes a feature and all samples
def separability_analysis(feature: str, mal_samples, ben_samples):
    sum_malign = 0
    sum_benign = 0

    occurance = dict()
    max_occurance = dict()
    TF = dict()
    TF_IDF_M = dict()
    TF_IDF_B = dict()

    # Get number of times feature occurs in malware samples.
    num_occur_mal_sample = 0
    for sample in mal_samples:
        if feature in sample:
            num_occur_mal_sample += 1
    
    num_occur_ben_sample = 0
    for sample in ben_samples:
        if feature in sample:
            num_occur_ben_sample += 1

    for sample in mal_samples:
        counter = Counter(sample)
        # Get how many times feature occurs in sample.
        occurance[sample] = counter[feature]
        # Get maximum occuring feature in the sample.
        if max_occurance[sample] is None:
            max_occurance[sample] = counter.most_common()[0][1]
        TF[sample] = occurance[sample] / max_occurance[sample]
        IDF_M = math.log(len(mal_samples) / num_occur_mal_sample)
        TF_IDF_M[sample] = TF[sample] * IDF_M
        sum_malign += TF_IDF_M[sample]
    
    mean_TF_IDF_M = sum_malign / len(mal_samples)

    for sample in ben_samples:
        counter = Counter(sample)
        # Get how many times feature occurs in sample.
        occurance[sample] = counter[feature]
        # Get maximum occuring feature in the sample.
        if max_occurance[sample] is None:
            max_occurance[sample] = counter.most_common()[0][1]
        TF[sample] = occurance[sample] / max_occurance[sample]
        IDF_B = math.log(len(ben_samples) / num_occur_ben_sample)
        TF_IDF_B[sample] = TF[sample] * IDF_B
        sum_benign += TF_IDF_B[sample]
    
    mean_TF_IDF_B = sum_benign / len(ben_samples)

    sum_malign = 0
    for sample in mal_samples:
        sum_malign += (TF_IDF_M[sample] - mean_TF_IDF_M)**2

    # Variance of feature in Malware class.
    var_mal = sum_malign / len(mal_samples)

    sum_benign = 0
    for sample in ben_samples:
        sum_benign += (TF_IDF_B[sample] - mean_TF_IDF_B)**2
    
    # Variance of feature in Benign class.
    var_ben = sum_benign / len(ben_samples)

    # Compute prior probabilites

    # Compute Within class variablity.
    within_class_var = (prior_prob_mal * var_mal) + (prior_prob_ben * var_ben)
    
    # Overall mean TF-IDF of feature.
    mean_TF_IDF = (sum(TF_IDF_M) + sum(TF_IDF_B)) / (len(mal_samples) + len(ben_samples))

    # Compute between class variability as variance of class centers with
    # respect to global centers.
    btwn_class_var = ((mean_TF_IDF_M - mean_TF_IDF)**2 + (mean_TF_IDF_B - mean_TF_IDF)**2) / (len(mal_samples) + len(ben_samples))
    
    # Compute total variability (the paper has a typo but I think this is correct)
    total_var = within_class_var + btwn_class_var

    # Compute separability score of the feature.
    score = total_var / within_class_var

    return score


def main():
    if len(sys.argv) != 3:
        print('USAGE: python %s [input directory [output file]' % sys.argv[0])

    input_dir = sys.argv[1]
    output_file = sys.argv[2]

    mal_samples = list()
    ben_samples = list()
    feature_set = set()

    for filename in os.listdir(input_dir):
        with open(input_dir + '/' + filename) as infile:
            try:
                lines = infile.read().splitlines()
            except:
                continue

        verdict = lines[0]
        if verdict == '0':
            ben_samples.append(lines[1:])
        elif verdict == '1':
            mal_samples.append(lines[1:])
        else:
            print('Error: First line of %s not 0 or 1' % filename)
            continue

        # Add features to set.
        for feature in lines[1:]:
            feature_set.add(feature)

    # Do Scatter/Separability Assessment for feature selection.
    scores = dict()
    for feature in feature_set:
        scores[feature] = separability_analysis(feature, mal_samples, ben_samples)

    # Make each element of feature vector the TF-IDF weight of a system call.

if __name__ == "__main__":
    main()
