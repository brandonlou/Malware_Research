import json
import multiprocessing as mp
import os
import sys
from utils.valid_api import is_valid_api


MIN_API_CALLS = 400 # From Section 6 of our paper.


def process_report(filename: str, input_dir: str, output_dir: str, verdict: int):
    with open(input_dir + '/' + filename, 'rt') as cuckoo_report:
        try:
            data = json.load(cuckoo_report)
        except:
            print('ERROR: Could not parse %s as JSON' % filename)
            return

    behavior = data.get('behavior')
    if behavior is None:
        print('ERROR: %s has no behavior section' % filename)
        return

    processes = behavior.get('processes')
    if processes is None:
        print('Error: %s has no processes section' % filename)
        return

    # List of APIs called in the report.
    api_list = list()
    
    num_api = 0;

    for process in processes:
        calls = process.get('calls')
        if calls is None:
            continue

        for call in calls:
            num_api += 1
            api_name = call.get('api')
            if not is_valid_api(api_name):
                continue
            api_list.append(api_name)

    if num_api <= MIN_API_CALLS:
        print('ERROR: %s does not have enough API calls' % filename)
        return

    output_file = '%s/%s_%d.txt' % (output_dir, filename, verdict)
    with open(output_file, 'wt') as outfile:
        outfile.write('%d\n' % verdict)
        for api in api_list:
            outfile.write('%s\n' % api)

    print('Success: %s' % filename)


def main():
    if len(sys.argv) != 4:
        print('Usage: python %s <reports directory> <output_directory> <0/1>' % sys.argv[0])
        exit()

    input_dir = sys.argv[1]
    output_dir = sys.argv[2]
    if sys.argv[3] == '0':
        verdict = 0 # Benign.
    elif sys.argv[3] == '1':
        verdict = 1 # Malicious.
    else:
        print('Usage: python %s <reports directory> <output_directory> <0/1>' % sys.argv[0])
        exit()

    pool = mp.Pool(mp.cpu_count()) # Use all CPU cores.
    for filename in os.listdir(input_dir):
        pool.apply_async(process_report, args=(filename, input_dir, output_dir, verdict))
    pool.close()
    pool.join()

if __name__ == "__main__":
    main()
